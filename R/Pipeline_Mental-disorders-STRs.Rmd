---
title: "Pipeline_Mental-disorders-STRs"
author: "Sergio Pérez Oliveira"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    toc_depth: 3
  pdf_document:
    toc: true
    number_sections: true
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Exploring the role of CAG repeats in *HTT*, *ATXN1* and *ATXN2* genes in the genetic architecture of mental disorders: schizophrenia and bipolar disorder.

The project aims to evaluate the role of intermediate-length **CAG repeats** in *HTT*, *ATXN1 (SCA1)*, and *ATXN2 (SCA2)* genes in the etiology of **schizophrenia (SCZ)** and **bipolar disorder (BD)**. We perform association analyses, regression models, and effect size calculations using R to investigate potential modifying roles of these STR loci in mental illness phenotypes.

## 01_Environment.R

Load and preprocess datasets for analysis of frequencies and correlations in mental disorder cohorts.

```{r}
# Required packages ----
required_packages <- c(
  "pwr", "rcompanion","writexl", "FSA", "installr", "xlsx", "dplyr", "readxl", "ggplot2",
  "corrplot", "devtools", "ggpubr", "lsr", "Rcmdr", "survival", "KMsurv",
  "survMisc", "survminer", "ggfortify", "flexsurv", "actuar", "nortest",
  "rstatix", "gtsummary", "car", "DataExplorer", "effectsize", "lmtest", 
  "nnet","igraph","tidyverse","ggraph","tidygraph","visNetwork","tidyr",
  "scales","stringr","grid","broom","boot","ggeffects","visreg","patchwork","rlang","cowplot"
)

install_and_load <- function(packages) {
  for (pkg in packages) {
    if (!requireNamespace(pkg, quietly = TRUE)) {
      install.packages(pkg)
    }
    library(pkg, character.only = TRUE)
  }
}

install_and_load(required_packages)

# Input section ----
# Select working directory interactively (select the main branch as directory)
if (interactive()) {
  if (requireNamespace("rstudioapi", quietly = TRUE) && rstudioapi::isAvailable()) {
    wd <- rstudioapi::selectDirectory(caption = "Select your working directory")
  } else if (.Platform$OS.type == "windows") {
    wd <- choose.dir(caption = "Select your working directory")
  } else {
    cat("Please set your working directory manually.\n")
    wd <- NULL
  }
  
  if (!is.null(wd)) {
    setwd(wd)
    cat("Working directory set to:", getwd(), "\n")
  } else {
    stop("No working directory selected. Please restart and select a directory.")
  }
} else {
  stop("Non-interactive session. Please set working directory manually.")
}

cat("Please select Mental disorders dataset (Excel):\n")
MENTAL <- read_excel(file.choose()) |> 
  select(-1) |> 
  select(-ADMISSION_AGE)

cat("Please select Control dataset (Excel):\n")
CONTROLS <- read_excel(file.choose())[-1, -1] |> 
  rename(AGE = DEATH_AGE)

# Functions ----

# Function to calculate mean and SD by category
mean_sd <- function(cohort, category, numeric_var, result_name) {
  categories <- unique(cohort[[category]])
  results <- data.frame()
  for (c in categories) {
    values <- na.omit(cohort[[numeric_var]][cohort[[category]] == c])
    results <- rbind(results, data.frame(
      CATEGORY = c,
      MEAN = round(mean(values), 2),
      SD = round(sd(values), 2)
    ))
  }
  colnames(results) <- c(category, paste(result_name, "MEAN"), paste(result_name, "SD"))
  return(results)
}

# Function to perform chi-square or Fisher's exact test with pairwise comparisons
my_function <- function(matrix) {
  chi_test <- chisq.test(matrix, correct = FALSE)
  perc_expected <- sum(chi_test$expected < 5) / length(chi_test$expected)
  
  if (perc_expected > 0.2) {
    fisher_test <- fisher.test(matrix)
    print("Fisher's test results:")
    print(fisher_test)
    test_result <- fisher_test$p.value
  } else {
    print("Chi-square test results:")
    print(chi_test)
    test_result <- chi_test$p.value
  }
  
  cat("\nMultiple comparisons:\n")
  print(pairwiseNominalIndependence(matrix, fisher = TRUE, chisq = TRUE, method = "holm"))
}

# Frequency table printing function
TABLE <- function(data, var1, var2, tableName) {
  cat(paste0("\nFrequency table: ", tableName, "\n"))
  table_mat <- xtabs(as.formula(paste("~", var1, "+", var2)), data = data)
  table_mat <- as.matrix(table_mat)
  table_mat[is.nan(table_mat)] <- 0
  print(table_mat)
}

# Data preprocessing ----

# Convert categorical variables to factors with labels
convert_factors <- function(df, list_of_vars_and_labels) {
  for (varname in names(list_of_vars_and_labels)) {
    df[[varname]] <- factor(df[[varname]], labels = list_of_vars_and_labels[[varname]])
  }
  return(df)
}

MENTAL <- convert_factors(MENTAL, list(
  PATHOLOGY = c("BD", "SCZ"),
  SEX = c("Male", "Female"),
  HTT_CODE = c("NORMAL", "IA", "EXPANDED"),
  ATXN1_CODE = c("NORMAL", "IA"),
  ATXN2_CODE = c("NORMAL", "IA", "EXPANDED"),
  COFFEE = c("Non-coffee", "Coffee"),
  SMOKER = c("Smoking", "Non-smoking"),
  CD_BINARY = c("No-CD", "CD")
))

CONTROLS <- convert_factors(CONTROLS, list(
  PATHOLOGY = "CONTROL",
  SEX = c("Male", "Female"),
  HTT_CODE = c("NORMAL", "IA", "EXPANDED"),
  ATXN1_CODE = c("NORMAL", "IA"),
  ATXN2_CODE = c("NORMAL", "IA"),
  SMOKER = c("Smoking", "Non-smoking")
))

MENTAL$APOE_E4 <- ifelse(MENTAL$APOE %in% c("34", "44"), 1, 0)
CONTROLS$APOE_E4 <- ifelse(CONTROLS$APOE %in% c("34", "44"), 1, 0)

MENTAL$APOE_E4 <- factor(MENTAL$APOE_E4, levels = c(0, 1),labels = c("E4-", "E4+"))
CONTROLS$APOE_E4 <- factor(CONTROLS$APOE_E4, levels = c(0, 1),labels = c("E4-", "E4+"))

# Convert numeric variables
to_numeric <- function(df, vars) {
  df[vars] <- lapply(df[vars], as.numeric)
  return(df)
}

MENTAL <- to_numeric(MENTAL, c("ALLELE1_HTT", "ALLELE2_HTT", "ALLELE1_ATXN1", "ALLELE2_ATXN1",
                               "ALLELE1_ATXN2", "ALLELE2_ATXN2", "AGE", "ONSET_AGE", "DURATION"))

CONTROLS <- to_numeric(CONTROLS, c("ALLELE1_HTT", "ALLELE2_HTT", "ALLELE1_ATXN1", "ALLELE2_ATXN1",
                                   "ALLELE1_ATXN2", "ALLELE2_ATXN2", "AGE"))
CONTROLS <- CONTROLS |> mutate(APOE = as.character(APOE))
MENTAL   <- MENTAL   |> mutate(APOE = as.character(APOE))

# Subsetting by pathology groups ----

# Bipolar Disorder subset and transformations
BD <- subset(MENTAL, PATHOLOGY == "BD")
BD <- BD |> mutate(
  CD = factor(CD, labels = c("NO", "MILD", "MODERATE", "SEVERE", "VERY-SEVERE")),
  PATHOLOGY_TYPE = factor(PATHOLOGY_TYPE, labels = c("BD-I", "BD-II", "Cyclothymia", "Substance-related", "Other-BD")),
  PATHOLOGY_TYPE_BINARY = factor(ifelse(PATHOLOGY_TYPE == "BD-I", "BD-I", "Other"), levels = c("BD-I", "Other")),
  BD_type = factor(
    case_when(
      is.na(PATHOLOGY_TYPE)      ~ NA_character_,
      PATHOLOGY_TYPE == "BD-I"   ~ "TBP1",
      PATHOLOGY_TYPE == "BD-II"  ~ "TBP2",
      TRUE                       ~ "Other"
    ),
    levels = c("TBP1", "TBP2", "Other")
  )
)

# SCZizophrenia subset and transformations
SCZ <- subset(MENTAL, PATHOLOGY == "SCZ")
SCZ <- SCZ |> mutate(
  PATHOLOGY_TYPE_BINARY = factor(ifelse(PATHOLOGY_TYPE == 1, "SCZ", "Other"), levels = c("SCZ", "Other")),
  CD = factor(CD, labels = c("NO", "MILD", "MODERATE", "SEVERE")),
)

# Add binary pathology columns to controls
CONTROLS$PATHOLOGY_TYPE_BINARY <- "CONTROL"
CONTROLS$CD_BINARY <- "CONTROL"

# Combine datasets ----

DT <- bind_rows(
  CONTROLS |> select(-CD_BINARY, -PATHOLOGY_TYPE_BINARY),
  MENTAL |> select(-COFFEE, -CD, -PATHOLOGY_TYPE, -ONSET_AGE, -DURATION)
)

DT$PATHOLOGY <- as.factor(DT$PATHOLOGY)

CONTROLS$BD_type <- "CONTROL"
BD_CONTROLS <- bind_rows(
  BD |> select(-COFFEE, -CD, -ONSET_AGE, -DURATION, -PATHOLOGY_TYPE),
  CONTROLS
)
CONTROLS <- CONTROLS |> select(-BD_type)

SCZ_CONTROLS <- bind_rows(
  SCZ |> select(-COFFEE,-CD, -ONSET_AGE, -DURATION, -PATHOLOGY_TYPE),
  CONTROLS
)

# Output section ----
# Save processed datasets for downstream analyses
if (!dir.exists("results")) {
  dir.create("results")
}

saveRDS(BD, file = "results/BD.rds")
saveRDS(SCZ, file = "results/SCZ.rds")
saveRDS(DT, file = "results/DT.rds")

# Save as XLSX
write_xlsx(BD, path = "results/BD.xlsx")
write_xlsx(SCZ, path = "results/SCZ.xlsx")
write_xlsx(DT, path = "results/DT.xlsx")

# Session info ----
sessionInfo()
```

## 02_Demographic_analysis.R

This script performs descriptive comparisons across psychiatric groups (SCZ, BD, Controls) and genotype frequency analyses for *HTT*, *ATXN1* and *ATXN2* loci across subgroups (e.g., binary subtype, CD, controls). Analyses include demographic, clinical, lifestyle variables and STR genotype distributions.

```{r}
# Age at onset ----
mean_sd(MENTAL, "PATHOLOGY", "ONSET_AGE", "Age at onset")
wilcox.test(ONSET_AGE ~ PATHOLOGY, data = MENTAL, exact = TRUE)
rank_biserial(ONSET_AGE ~ PATHOLOGY, data = MENTAL)

# Age at death / last visit ----
mean_sd(DT, "PATHOLOGY", "AGE", "Age at death / last visit")
kruskal.test(AGE ~ PATHOLOGY, data = DT)
epsilonSquared(x=DT$AGE,g=DT$PATHOLOGY, ci=TRUE)
dunn <- dunnTest(DT$AGE ~ DT$PATHOLOGY, method = "holm")
print(dunn, dunn.test.results = TRUE)
pairwise.wilcox.test(x = DT$AGE, g = DT$PATHOLOGY, p.adjust.method = "holm")

# Rank biserial effect sizes by pairwise comparison
levels <- unique(DT$PATHOLOGY)
comparisons <- combn(levels, 2, simplify = FALSE)
for (pair in comparisons) {
  cat("\nComparison:", pair[1], "vs", pair[2], "\n")
  sub_data <- subset(DT, PATHOLOGY %in% pair)
  sub_data$PATHOLOGY <- factor(sub_data$PATHOLOGY, levels = pair)
  print(rank_biserial(AGE ~ PATHOLOGY, data = sub_data))
}

# Disease duration ----
mean_sd(MENTAL, "PATHOLOGY", "DURATION", "Disease duration")
wilcox.test(DURATION ~ PATHOLOGY, data = MENTAL, exact = TRUE)
pairwise.wilcox.test(x = MENTAL$DURATION, g = MENTAL$PATHOLOGY, p.adjust.method = "holm")
rank_biserial(DURATION ~ PATHOLOGY, data = MENTAL)


# Sex distribution ----
Table <- TABLE(DT, "PATHOLOGY", "SEX", "Sex distribution")
rowPercents(Table)
my_function(Table)
pairwise_fisher_test(Table, p.adjust.method = "holm", conf.int = TRUE, detailed = TRUE)

# Smoking status ----
smoking_tab <- TABLE(MENTAL, "PATHOLOGY", "SMOKER", "Smoking by pathology")
rowPercents(smoking_tab)
my_function(smoking_tab)
pairwise_fisher_test(smoking_tab, p.adjust.method = "holm", conf.int = TRUE, detailed = TRUE)

# Coffee consumption ----
coffee_tab <- TABLE(MENTAL, "PATHOLOGY", "COFFEE", "Coffee consumption by pathology")
rowPercents(coffee_tab)
my_function(coffee_tab)
pairwise_fisher_test(coffee_tab, p.adjust.method = "holm", conf.int = TRUE, detailed = TRUE)

# Cognitive decline ----

cd_tab <- table(BD$CD)
cd_percent <- round(prop.table(cd_tab) * 100, 2)
cd_tab
cd_percent

cd_bin_tab <- table(BD$CD_BINARY)
round(prop.table(cd_bin_tab) * 100, 2)
cd_bin_tab

cd_tab <- table(SCZ$CD)
cd_percent <- round(prop.table(cd_tab) * 100, 2)
cd_tab
cd_percent

cd_bin_tab <- table(SCZ$CD_BINARY)
round(prop.table(cd_bin_tab) * 100, 2)
cd_bin_tab

# Subtype of pathology ----

subtype_tab <- table(BD$PATHOLOGY_TYPE)
round(prop.table(subtype_tab) * 100, 2)
subtype_tab
subtype_bin_tab <- table(BD$PATHOLOGY_TYPE_BINARY)
round(prop.table(subtype_bin_tab) * 100, 2)
subtype_bin_tab

subtype_TBP_tab <- table(BD$BD_type)
round(prop.table(subtype_TBP_tab) * 100, 2)
subtype_TBP_tab


SCZ_type_tab <- table(SCZ$PATHOLOGY_TYPE)
round(prop.table(SCZ_type_tab) * 100, 2)
SCZ_type_tab
SCZ_type_bin_tab <- table(SCZ$PATHOLOGY_TYPE_BINARY)
round(prop.table(SCZ_type_bin_tab) * 100, 2)
SCZ_type_bin_tab


# Missing data ----
DT %>%
  group_by(PATHOLOGY) %>%
  summarise(across(everything(), ~ sum(is.na(.))))

MENTAL %>%
  group_by(PATHOLOGY) %>%
  summarise(across(everything(), ~ sum(is.na(.))))


# Session info ----
sessionInfo()
```

## 03_Genotype_stats.R

This script performs genotype frequency comparisons across groups (SCZ, BD, Controls) for genes associated with neurodegenerative disorders: HTT, ATXN1 (SCA1), and ATXN2 (SCA2). The analysis includes global frequencies, intermediate alleles (IAs), expanded alleles, and subgroup comparisons by clinical subtype and severity (DCO).

```{r}
# Function to run genotype frequency analysis ----
run_genotype_analysis <- function(data, group_col, genotype_col, label, drop_cols = NULL) {
  tab <- TABLE(data, group_col, genotype_col, label)
  print(rowPercents(tab))
  my_function(tab)
  
  if (!is.null(drop_cols)) {
    cols <- colnames(tab)
    idx_drop <- if (is.numeric(drop_cols)) intersect(drop_cols, seq_along(cols)) else match(drop_cols, cols, nomatch = 0)
    tab <- tab[, setdiff(seq_along(cols), idx_drop), drop = FALSE]
  }
  
  if (ncol(tab) == 2 && nrow(tab) >= 2) {
    pairwise_fisher_test(tab, p.adjust.method = "holm", conf.int = TRUE, detailed = TRUE)
  } else {
    message("Pairwise Fisher skipped: requires 2 genotype columns and >=2 groups.")
  }
}

# HTT ANALYSIS =================
run_genotype_analysis(DT, "PATHOLOGY", "HTT_CODE", "HTT: Main group comparison")
run_genotype_analysis(DT, "PATHOLOGY", "HTT_CODE", "HTT: Intermediate alleles", drop_cols = 3)
run_genotype_analysis(DT, "PATHOLOGY", "HTT_CODE", "HTT: Expanded alleles", drop_cols = 2)

run_genotype_analysis(BD_CONTROLS, "PATHOLOGY_TYPE_BINARY	", "HTT_CODE", "HTT vs type of BD", drop_cols = 3)
run_genotype_analysis(BD_CONTROLS, "PATHOLOGY_TYPE_BINARY	", "HTT_CODE", "HTT vs type of BD (expanded)", drop_cols = 2)
run_genotype_analysis(BD_CONTROLS, "CD_BINARY", "HTT_CODE", "HTT vs CD severity in BD", drop_cols = 3)

run_genotype_analysis(SCZ_CONTROLS, "PATHOLOGY_TYPE_BINARY	", "HTT_CODE", "HTT vs type of SCZ", drop_cols = 3)
run_genotype_analysis(SCZ_CONTROLS, "CD_BINARY", "HTT_CODE", "HTT vs CD severity in SCZ", drop_cols = 3)

# ATXN1 ANALYSIS =================
run_genotype_analysis(DT, "PATHOLOGY", "ATXN1_CODE", "ATXN1: IA comparison")
run_genotype_analysis(DT, "PATHOLOGY", "ATXN1_CODE", "ATXN1: Intermediate alleles", drop_cols = 3)

run_genotype_analysis(BD_CONTROLS, "PATHOLOGY_TYPE_BINARY	", "ATXN1_CODE", "ATXN1 vs type of BD", drop_cols = 3)
run_genotype_analysis(BD_CONTROLS, "CD_BINARY", "ATXN1_CODE", "ATXN1 vs CD severity in BD", drop_cols = 3)

run_genotype_analysis(SCZ_CONTROLS, "PATHOLOGY_TYPE_BINARY	", "ATXN1_CODE", "ATXN1 vs type of SCZ", drop_cols = 3)
run_genotype_analysis(SCZ_CONTROLS, "CD_BINARY", "ATXN1_CODE", "ATXN1 vs CD severity in SCZ", drop_cols = 3)

# ATXN2 ANALYSIS =================
run_genotype_analysis(DT, "PATHOLOGY", "ATXN2_CODE", "ATXN2: Main group comparison")
run_genotype_analysis(DT, "PATHOLOGY", "ATXN2_CODE", "ATXN2: Intermediate alleles", drop_cols = 3)
run_genotype_analysis(DT, "PATHOLOGY", "ATXN2_CODE", "ATXN2: Expanded alleles", drop_cols = 2)

run_genotype_analysis(BD_CONTROLS, "PATHOLOGY_TYPE_BINARY	", "ATXN2_CODE", "ATXN2 vs type of BD", drop_cols = 3)
run_genotype_analysis(BD_CONTROLS, "PATHOLOGY_TYPE_BINARY	", "ATXN2_CODE", "ATXN2 vs type of BD (expanded)", drop_cols = 2)
run_genotype_analysis(BD_CONTROLS, "CD_BINARY", "ATXN2_CODE", "ATXN2 vs CD severity in BD", drop_cols = 3)

run_genotype_analysis(SCZ_CONTROLS, "PATHOLOGY_TYPE_BINARY	", "ATXN2_CODE", "ATXN2 vs type of SCZ", drop_cols = 3)
run_genotype_analysis(SCZ_CONTROLS, "CD_BINARY", "ATXN2_CODE", "ATXN2 vs CD severity in SCZ", drop_cols = 3)

#APOE & COGNITIVE DECLINE ----
run_genotype_analysis(DT, "PATHOLOGY", "APOE_E4", "APOE E4: main comparison")
run_genotype_analysis(BD_CONTROLS, "PATHOLOGY_TYPE_BINARY	", "APOE_E4", "APOE E4: main comparison")
run_genotype_analysis(BD, "BD_type", "APOE_E4", "APOE E4: main comparison")
run_genotype_analysis(BD_CONTROLS, "CD_BINARY", "APOE_E4", "APOE E4: main comparison")
run_genotype_analysis(SCZ_CONTROLS, "PATHOLOGY_TYPE_BINARY	", "APOE_E4", "APOE E4: main comparison")
run_genotype_analysis(SCZ_CONTROLS, "CD_BINARY", "APOE_E4", "APOE E4: main comparison")

run_genotype_analysis(BD, "CD_BINARY", "APOE_E4", "CD and APOE")
run_genotype_analysis(SCZ, "CD_BINARY", "APOE_E4", "CD and APOE")

# Session info ----
sessionInfo()
```

## 04_CAG_repeat_sizes.R

This script performs non-parametric statistical analyses to compare CAG repeat lengths of both alleles in *HTT*, *ATXN1*, and *ATXN2* across diagnostic groups (SCZ, BD, Controls), as well as in clinically defined subgroups based on subtype and severity (DCO).

The analysis includes:

-   Descriptive statistics (mean and SD per group)

-   Kruskal-Wallis test for global group differences

-   Dunn and Wilcoxon pairwise post-hoc tests if significant

-   Effect size estimation (Wilcoxon-based) for selected comparisons

-   CAG repeat sizes and its percentages in the different cohorts.

```{r}
run_kruskal_analysis <- function(df, group_col, value_col,
                                 result_name = NULL,
                                 comparisons_list = NULL,
                                 p_adjust = "holm",
                                 run_pairwise_always = TRUE,
                                 exact_wilcox = FALSE) {
  # Packages needed: FSA, rcompanion, rstatix, dplyr
  # library(FSA); library(rcompanion); library(rstatix); library(dplyr)
  
  if (is.null(result_name)) result_name <- value_col
  
  cat("\n--- Analysis for:", result_name, "---\n")
  
  # Basic checks
  if (!group_col %in% names(df)) stop("group_col not found in df")
  if (!value_col %in% names(df)) stop("value_col not found in df")
  
  # Drop rows with missing group/value to keep n consistent
  dsub <- df[!is.na(df[[group_col]]) & !is.na(df[[value_col]]), , drop = FALSE]
  dsub[[group_col]] <- factor(dsub[[group_col]])
  
  # 1) Descriptives
  cat("Mean and SD by group:\n")
  mean_sd_result <- mean_sd(dsub, group_col, value_col, result_name = value_col)
  print(mean_sd_result)
  
  # 2) Kruskal–Wallis
  cat("\nKruskal–Wallis test:\n")
  kw <- kruskal.test(dsub[[value_col]] ~ dsub[[group_col]])
  print(kw)
  
  # 3) Global effect size: epsilon-squared (ε²)
  cat("\nGlobal effect size (epsilon-squared, ε²):\n")
  eps2 <- rcompanion::epsilonSquared(x = dsub[[value_col]], g = dsub[[group_col]])
  print(eps2)
  
  # Decide whether to run pairwise
  run_pairwise <- run_pairwise_always || (kw$p.value < 0.05)
  
  if (run_pairwise) {
    if (kw$p.value < 0.05) {
      cat("\nPost hoc tests (inferential; KW significant):\n")
    } else {
      cat("\nPost hoc tests (exploratory; KW not significant):\n")
    }
    
    # 4) Dunn post hoc (Holm or chosen adjustment)
    cat("\nDunn's test (p-adjust =", p_adjust, "):\n")
    dunn_result <- FSA::dunnTest(
      dsub[[value_col]] ~ dsub[[group_col]],
      method = p_adjust
    )
    print(dunn_result)
    
    # 5) Pairwise Wilcoxon (same p-adjust)
    cat("\nPairwise Wilcoxon test (p-adjust =", p_adjust, "):\n")
    wilcox_result <- pairwise.wilcox.test(
      x = dsub[[value_col]],
      g = dsub[[group_col]],
      p.adjust.method = p_adjust,
      exact = exact_wilcox
    )
    print(wilcox_result)
    
    # 6) Pairwise effect sizes (rank-biserial) for selected comparisons
    if (!is.null(comparisons_list)) {
      cat("\nPairwise effect sizes (rank-biserial correlation; p-adjust =", p_adjust, "):\n")
      effsize <- dsub %>%
        rstatix::wilcox_effsize(
          as.formula(paste(value_col, "~", group_col)),
          paired = FALSE,
          comparisons = comparisons_list,
          p.adjust.method = p_adjust
        )
      print(effsize)
    } else {
      cat("\nNo comparisons_list provided for effect sizes.\n")
    }
    
  } else {
    cat("\nPairwise tests were not run.\n")
  }
  
  # Return objects invisibly (useful for saving)
  invisible(list(
    descriptives = mean_sd_result,
    kw = kw,
    eps2 = eps2,
    dunn = if (run_pairwise) dunn_result else NULL,
    pairwise_wilcox = if (run_pairwise) wilcox_result else NULL,
    pairwise_effsize = if (run_pairwise && !is.null(comparisons_list)) effsize else NULL
  ))
}



# HTT ANALYSIS ----

### Long allele
run_kruskal_analysis(DT, "PATHOLOGY", "ALLELE2_HTT", "HTT long allele", list(c("BD","SCZ"), c("BD","CONTROL"), c("SCZ","CONTROL")))

run_kruskal_analysis(BD_CONTROLS, "PATHOLOGY_TYPE_BINARY", "ALLELE2_HTT", "HTT long allele BD_CONTROLS - Pathology type", list(c("BD-I","Other"), c("BD-I","CONTROL"), c("Other","CONTROL")))
run_kruskal_analysis(BD_CONTROLS, "CD_BINARY", "ALLELE2_HTT", "HTT long allele BD_CONTROLS - Severity", list(c("CD","No-CD"), c("CD","CONTROL"), c("No-CD","CONTROL")))

run_kruskal_analysis(SCZ_CONTROLS, "PATHOLOGY_TYPE_BINARY", "ALLELE2_HTT", "HTT long allele SCZ_CONTROLS - Pathology type", list(c("SCZ","Other"), c("Other","CONTROL"), c("SCZ","CONTROL")))
run_kruskal_analysis(SCZ_CONTROLS, "CD_BINARY", "ALLELE2_HTT", "HTT long allele SCZ_CONTROLS - Severity", list(c("CD","No-CD"), c("CD","CONTROL"), c("No-CD","CONTROL")))

### Short allele
run_kruskal_analysis(DT, "PATHOLOGY", "ALLELE1_HTT", "HTT short allele", list(c("BD","SCZ"), c("BD","CONTROL"), c("SCZ","CONTROL")))

run_kruskal_analysis(BD_CONTROLS, "PATHOLOGY_TYPE_BINARY", "ALLELE1_HTT", "HTT short allele BD_CONTROLES - Pathology type", list(c("BD-I","Other"), c("BD-I","CONTROL"), c("Other","CONTROL")))
run_kruskal_analysis(BD_CONTROLS, "CD_BINARY", "ALLELE1_HTT", "HTT short allele BD_CONTROLES - Severity", list(c("CD","No-CD"), c("CD","CONTROL"), c("No-CD","CONTROL")))

run_kruskal_analysis(SCZ_CONTROLS, "PATHOLOGY_TYPE_BINARY", "ALLELE1_HTT", "HTT short allele SCZ_CONTROLS - Pathology type", list(c("SCZ","Other"), c("Other","CONTROL"), c("SCZ","CONTROL")))
run_kruskal_analysis(SCZ_CONTROLS, "CD_BINARY", "ALLELE1_HTT", "HTT short allele SCZ_CONTROLS - Severity", list(c("CD","No-CD"), c("CD","CONTROL"), c("No-CD","CONTROL")))

# ATXN1 ANALYSIS ----

### Long allele
run_kruskal_analysis(DT, "PATHOLOGY", "ALLELE2_ATXN1", "ATXN1 long allele", list(c("BD","SCZ"), c("BD","CONTROL"), c("SCZ","CONTROL")))

run_kruskal_analysis(BD_CONTROLS, "PATHOLOGY_TYPE_BINARY", "ALLELE2_ATXN1", "ATXN1 long allele BD_CONTROLES - Pathology type", list(c("BD-I","Other"), c("BD-I","CONTROL"), c("Other","CONTROL")))
run_kruskal_analysis(BD_CONTROLS, "CD_BINARY", "ALLELE2_ATXN1", "ATXN1 long allele BD_CONTROLES - Severity", list(c("CD","No-CD"), c("CD","CONTROL"), c("No-CD","CONTROL")))

run_kruskal_analysis(SCZ_CONTROLS, "PATHOLOGY_TYPE_BINARY", "ALLELE2_ATXN1", "ATXN1 long allele SCZ_CONTROLS - Pathology type", list(c("SCZ","Other"), c("Other","CONTROL"), c("SCZ","CONTROL")))
run_kruskal_analysis(SCZ_CONTROLS, "CD_BINARY", "ALLELE2_ATXN1", "ATXN1 long allele SCZ_CONTROLS - Severity", list(c("CD","No-CD"), c("CD","CONTROL"), c("No-CD","CONTROL")))

### Short allele
run_kruskal_analysis(DT, "PATHOLOGY", "ALLELE1_ATXN1", "ATXN1 short allele", list(c("BD","SCZ"), c("BD","CONTROL"), c("SCZ","CONTROL")))

run_kruskal_analysis(BD_CONTROLS, "PATHOLOGY_TYPE_BINARY", "ALLELE1_ATXN1", "ATXN1 short allele BD_CONTROLES - Pathology type", list(c("BD-I","Other"), c("BD-I","CONTROL"), c("Other","CONTROL")))
run_kruskal_analysis(BD_CONTROLS, "CD_BINARY", "ALLELE1_ATXN1", "ATXN1 short allele BD_CONTROLES - Severity", list(c("CD","No-CD"), c("CD","CONTROL"), c("No-CD","CONTROL")))

run_kruskal_analysis(SCZ_CONTROLS, "PATHOLOGY_TYPE_BINARY", "ALLELE1_ATXN1", "ATXN1 short allele SCZ_CONTROLS - Pathology type", list(c("SCZ","Other"), c("Other","CONTROL"), c("SCZ","CONTROL")))
run_kruskal_analysis(SCZ_CONTROLS, "CD_BINARY", "ALLELE1_ATXN1", "ATXN1 short allele SCZ_CONTROLS - Severity", list(c("CD","No-CD"), c("CD","CONTROL"), c("No-CD","CONTROL")))

# ATXN2 ANALYSIS ----

### Long allele
run_kruskal_analysis(DT, "PATHOLOGY", "ALLELE2_ATXN2", "ATXN2 long allele", list(c("BD","SCZ"), c("BD","CONTROL"), c("SCZ","CONTROL")))

run_kruskal_analysis(BD_CONTROLS, "PATHOLOGY_TYPE_BINARY", "ALLELE2_ATXN2", "ATXN2 long allele BD_CONTROLES - Pathology type", list(c("BD-I","Other"), c("BD-I","CONTROL"), c("Other","CONTROL")))
run_kruskal_analysis(BD_CONTROLS, "CD_BINARY", "ALLELE2_ATXN2", "ATXN2 long allele BD_CONTROLES - Severity", list(c("CD","No-CD"), c("CD","CONTROL"), c("No-CD","CONTROL")))

run_kruskal_analysis(SCZ_CONTROLS, "PATHOLOGY_TYPE_BINARY", "ALLELE2_ATXN2", "ATXN2 long allele SCZ_CONTROLS - Pathology type", list(c("SCZ","Other"), c("Other","CONTROL"), c("SCZ","CONTROL")))
run_kruskal_analysis(SCZ_CONTROLS, "CD_BINARY", "ALLELE2_ATXN2", "ATXN2 long allele SCZ_CONTROLS - Severity", list(c("CD","No-CD"), c("CD","CONTROL"), c("No-CD","CONTROL")))

### Short allele
run_kruskal_analysis(DT, "PATHOLOGY", "ALLELE1_ATXN2", "ATXN2 short allele", list(c("BD","SCZ"), c("BD","CONTROL"), c("SCZ","CONTROL")))

run_kruskal_analysis(BD_CONTROLS, "PATHOLOGY_TYPE_BINARY", "ALLELE1_ATXN2", "ATXN2 short allele BD_CONTROLES - Pathology type", list(c("BD-I","Other"), c("BD-I","CONTROL"), c("Other","CONTROL")))
run_kruskal_analysis(BD_CONTROLS, "CD_BINARY", "ALLELE1_ATXN2", "ATXN2 short allele BD_CONTROLES - Severity", list(c("CD","No-CD"), c("CD","CONTROL"), c("No-CD","CONTROL")))

run_kruskal_analysis(SCZ_CONTROLS, "PATHOLOGY_TYPE_BINARY", "ALLELE1_ATXN2", "ATXN2 short allele SCZ_CONTROLS - Pathology type", list(c("SCZ","Other"), c("Other","CONTROL"), c("SCZ","CONTROL")))
run_kruskal_analysis(SCZ_CONTROLS, "CD_BINARY", "ALLELE1_ATXN2", "ATXN2 short allele SCZ_CONTROLS - Severity", list(c("CD","No-CD"), c("CD","CONTROL"), c("No-CD","CONTROL")))

#CAG repeats frequencies among cohorts----

allele_percentages_by_group <- function(
    data,
    group_var      = "PATHOLOGY",
    allele_cols    = c("ALLELE1_HTT", "ALLELE2_HTT"),  # <- pass ATXN1/ATXN2 here when needed
    group_to_show  = NULL,                              # e.g. "BD", "SCZ", "CONTROL"
    output         = c("long", "wide"),                 # output format
    digits         = 2,
    drop_na        = TRUE
) {
  output <- match.arg(output)
  
  # Check that all requested columns exist in the dataset
  missing_cols <- setdiff(c(group_var, allele_cols), names(data))
  if (length(missing_cols) > 0) {
    stop("These columns were No-CDt found in 'data': ", paste(missing_cols, collapse = ", "))
  }
  
  # Convert selected allele columns to long format
  allele_long <- data %>%
    select(all_of(group_var), all_of(allele_cols)) %>%
    pivot_longer(
      cols      = all_of(allele_cols),
      names_to  = "ALLELE_COL",
      values_to = "CAG_size"
    )
  
  # Optionally remove rows with missing allele values
  if (drop_na) {
    allele_long <- allele_long %>% filter(!is.na(CAG_size))
  }
  
  # Compute frequency and percentage by group and allele size
  allele_freq <- allele_long %>%
    group_by(across(all_of(group_var)), CAG_size) %>%
    summarise(count = n(), .groups = "drop_last") %>%
    mutate(
      percentage = round(100 * count / sum(count), digits)  # % within each group
    ) %>%
    arrange(across(all_of(group_var)), CAG_size)
  
  # Optionally filter to show only one specific group
  if (!is.null(group_to_show)) {
    allele_freq <- allele_freq %>%
      filter(!!sym(group_var) == group_to_show)
  }
  
  # Return results in wide format if requested
  if (output == "wide") {
    res <- allele_freq %>%
      select(all_of(group_var), CAG_size, percentage) %>%
      pivot_wider(
        names_from  = all_of(group_var),
        values_from = percentage,
        values_fill = 0
      ) %>%
      arrange(CAG_size)
  } else {
    res <- allele_freq
  }
  
  # Print and return the result invisibly
  print(res)
  invisible(res)
}

allele_percentages_by_group(DT,  allele_cols = c("ALLELE1_HTT", "ALLELE2_HTT"),  group_to_show = "CONTROL")
allele_percentages_by_group(DT,  allele_cols = c("ALLELE1_HTT", "ALLELE2_HTT"),  group_to_show = "BD")
allele_percentages_by_group(DT,  allele_cols = c("ALLELE1_HTT", "ALLELE2_HTT"),  group_to_show = "SCZ")

allele_percentages_by_group(DT,  allele_cols = c("ALLELE1_ATXN1", "ALLELE2_ATXN1"),  group_to_show = "CONTROL")
allele_percentages_by_group(DT,  allele_cols = c("ALLELE1_ATXN1", "ALLELE2_ATXN1"),  group_to_show = "BD")
allele_percentages_by_group(DT,  allele_cols = c("ALLELE1_ATXN1", "ALLELE2_ATXN1"),  group_to_show = "SCZ")

allele_percentages_by_group(DT,  allele_cols = c("ALLELE1_ATXN2", "ALLELE2_ATXN2"),  group_to_show = "CONTROL")
allele_percentages_by_group(DT,  allele_cols = c("ALLELE1_ATXN2", "ALLELE2_ATXN2"),  group_to_show = "BD")
allele_percentages_by_group(DT,  allele_cols = c("ALLELE1_ATXN2", "ALLELE2_ATXN2"),  group_to_show = "SCZ")


# Session info ----
sessionInfo()
```

## 05_Regression_models.R

This script performs regression analyses to investigate:

1)  Association between STR genotypes (*HTT*, *ATXN1*, *ATXN2*) and:

\- Risk of psychiatric disorders (BD, SCZ vs controls)

Risk of clinical subtypes (e.g., bipolar subtypes)

\- Risk of cognitive deterioration (CD)

2)  Association between STRs and age-of-onset in psychiatric disorders Includes covariate adjustment, model selection, and effect size calculations.

```{r}

# 1. MENTAL DISORDER RISK MODEL (Multinomial) ======
# Final: One model per gene (short + long + quadratic + interaction), adjusted for SEX + AGE + APOE_E4
# Plus: corrected block-deletion error for ATXN2.

# Data prep ----
DT <- DT %>%
  mutate(
    PATHOLOGY = relevel(factor(PATHOLOGY), ref = "CONTROL"),
    SEX = factor(SEX)
  ) %>%
  filter(
    ATXN1_CODE != "EXPANDED",
    ATXN2_CODE != "EXPANDED",
    HTT_CODE  != "EXPANDED"
  ) %>%
  mutate(
    ATXN1_CODE = droplevels(factor(ATXN1_CODE)),
    ATXN2_CODE = droplevels(factor(ATXN2_CODE)),
    HTT_CODE  = droplevels(factor(HTT_CODE))
  )

drop_na_vars <- function(df, vars) {
  dplyr::filter(df, dplyr::if_all(dplyr::all_of(vars), ~ !is.na(.)))
}

vars_allele <- c(
  "PATHOLOGY", "SEX", "AGE", "APOE_E4",
  "ALLELE1_ATXN1","ALLELE2_ATXN1","ALLELE1_ATXN2","ALLELE2_ATXN2","ALLELE1_HTT","ALLELE2_HTT"
)
DT_allele <- drop_na_vars(DT, vars_allele)

# Full poly model (used only for block-deletion AIC) ----
model_full_poly <- nnet::multinom(
  PATHOLOGY ~
    SEX + AGE + APOE_E4 +
    # ATXN1
    ALLELE1_ATXN1 + I(ALLELE1_ATXN1^2) +
    ALLELE2_ATXN1 + I(ALLELE2_ATXN1^2) +
    ALLELE1_ATXN1:ALLELE2_ATXN1 +
    # ATXN2
    ALLELE1_ATXN2 + I(ALLELE1_ATXN2^2) +
    ALLELE2_ATXN2 + I(ALLELE2_ATXN2^2) +
    ALLELE1_ATXN2:ALLELE2_ATXN2 +
    # HTT
    ALLELE1_HTT + I(ALLELE1_HTT^2) +
    ALLELE2_HTT + I(ALLELE2_HTT^2) +
    ALLELE1_HTT:ALLELE2_HTT,
  data = DT_allele,
  trace = FALSE
)

# Block-deletion models ----
model_no_HTT <- update(
  model_full_poly,
  . ~ . -
    ALLELE1_HTT - I(ALLELE1_HTT^2) -
    ALLELE2_HTT - I(ALLELE2_HTT^2) -
    ALLELE1_HTT:ALLELE2_HTT
)

model_no_ATXN1 <- update(
  model_full_poly,
  . ~ . -
    ALLELE1_ATXN1 - I(ALLELE1_ATXN1^2) -
    ALLELE2_ATXN1 - I(ALLELE2_ATXN1^2) -
    ALLELE1_ATXN1:ALLELE2_ATXN1
)

model_no_ATXN2 <- update(
  model_full_poly,
  . ~ . -
    ALLELE1_ATXN2 - I(ALLELE1_ATXN2^2) -
    ALLELE2_ATXN2 - I(ALLELE2_ATXN2^2) -
    ALLELE1_ATXN2:ALLELE2_ATXN2
)

aic_tbl <- tibble::tibble(
  model = c("Full (HTT+ATXN1+ATXN2)", "No HTT", "No ATXN1", "No ATXN2"),
  AIC = c(AIC(model_full_poly), AIC(model_no_HTT), AIC(model_no_ATXN1), AIC(model_no_ATXN2))
) %>%
  dplyr::mutate(delta_AIC = AIC - min(AIC)) %>%
  dplyr::arrange(AIC)

print(aic_tbl)

# Final models: ONE per gene ======
# Each model: covariates + (short linear+quadratic) + (long linear+quadratic) + interaction

fit_gene_multinom <- function(df, outcome = "PATHOLOGY",
                              covars = c("SEX","AGE","APOE_E4"),
                              short, long) {
  f <- as.formula(paste(
    outcome, "~",
    paste(covars, collapse = " + "), "+",
    paste0(short, " + I(", short, "^2) + ",
           long,  " + I(", long,  "^2) + ",
           short, ":", long)
  ))
  nnet::multinom(f, data = df, trace = FALSE)
}

tidy_multinom_or <- function(m) {
  broom::tidy(m, exponentiate = TRUE, conf.int = TRUE) %>%
    dplyr::filter(term != "(Intercept)")
}

# 1) HTT final
model_HTT_final <- fit_gene_multinom(
  df = DT_allele,
  short = "ALLELE1_HTT",
  long  = "ALLELE2_HTT"
)
summary(model_HTT_final)
tt_HTT_final <- tidy_multinom_or(model_HTT_final)
tt_HTT_final
lmtest::lrtest(model_HTT_final, model_full_poly)
lmtest::lrtest(model_no_HTT, model_full_poly)

# 2) ATXN1 final
model_ATXN1_final <- fit_gene_multinom(
  df = DT_allele,
  short = "ALLELE1_ATXN1",
  long  = "ALLELE2_ATXN1"
)
summary(model_ATXN1_final)
tt_ATXN1_final <- tidy_multinom_or(model_ATXN1_final)
tt_ATXN1_final
lmtest::lrtest(model_no_ATXN1, model_full_poly)

# 3) ATXN2 final
model_ATXN2_final <- fit_gene_multinom(
  df = DT_allele,
  short = "ALLELE1_ATXN2",
  long  = "ALLELE2_ATXN2"
)
summary(model_ATXN2_final)
tt_ATXN2_final <- tidy_multinom_or(model_ATXN2_final)
tt_ATXN2_final
lmtest::lrtest(model_no_ATXN2, model_full_poly)

# FIGURE 2.1 ATXN2 multinomial figure ----
# --- Settings
fig_dir <- "figures"
if (!dir.exists(fig_dir)) dir.create(fig_dir, recursive = TRUE)

# Ensure model and tidy data exist
model_plot <- model_ATXN2_final 
tt_plot <- broom::tidy(model_plot, exponentiate = TRUE, conf.int = TRUE)

# --- Settings Colors & Limits
cols_outcome <- c("BD" = "#8CBDE6", "SCZ" = "#F5A04D")
x_min <- 1e-3
x_max <- 1e4

# --- Data Preparation
df_fp <- tt_plot %>%
  filter(term != "(Intercept)") %>%
  mutate(
    outcome = factor(str_trim(as.character(y.level)), levels = c("BD", "SCZ")),
    
    # MODIFICATION: Using atop() to split labels into two lines
    term_label = case_when(
      term == "SEX[T.Female]" ~ "'Female sex'",
      term == "AGE" ~ "'Age'",
      
      term == "APOE_E4[T.E4+]" ~ "italic(APOE)~epsilon[4]~carrier",
      
      # Split ATXN2 labels:
      term == "ALLELE1_ATXN2" ~ "atop(italic(ATXN2), 'short allele (linear)')",
      stringr::str_detect(term, "^I\\(ALLELE1_ATXN2\\^2\\)") ~ "atop(italic(ATXN2), 'short allele (quadratic)')",
      
      term == "ALLELE2_ATXN2" ~ "atop(italic(ATXN2), 'long allele (linear)')",
      stringr::str_detect(term, "^I\\(ALLELE2_ATXN2\\^2\\)") ~ "atop(italic(ATXN2), 'long allele (quadratic)')",
      
      term == "ALLELE1_ATXN2:ALLELE2_ATXN2" ~ "atop(italic(ATXN2), 'short x long allele (interaction)')",
      TRUE ~ term
    ),
    
    # Stats processing
    p_plot = pmax(p.value, 1e-300),
    sig = -log10(p_plot),
    est_p = pmin(pmax(estimate,  x_min), x_max),
    lo_p  = pmin(pmax(conf.low,  x_min), x_max),
    hi_p  = pmin(pmax(conf.high, x_min), x_max),
    cut_left  = conf.low  < x_min,
    cut_right = conf.high > x_max
  )

# --- Order terms (Must match the strings in case_when EXACTLY)
order_terms <- c(
  "'Female sex'", 
  "'Age'", 
  "italic(APOE)~epsilon[4]~carrier",
  "atop(italic(ATXN2), 'short allele (linear)')",
  "atop(italic(ATXN2), 'short allele (quadratic)')",
  "atop(italic(ATXN2), 'long allele (linear)')",
  "atop(italic(ATXN2), 'long allele (quadratic)')",
  "atop(italic(ATXN2), 'short x long allele (interaction)')"
)

df_fp <- df_fp %>%
  mutate(term_label = factor(term_label, levels = rev(order_terms)))

# --- Plotting
pd <- position_dodge(width = 0.55)

g_forest <- ggplot(df_fp, aes(x = est_p, y = term_label)) +
  coord_cartesian(xlim = c(x_min, x_max), clip = "off") +
  
  geom_vline(xintercept = 1, linetype = "dashed",
             linewidth = 0.6, color = "grey45") +
  
  # Error bars
  geom_errorbarh(
    aes(xmin = lo_p, xmax = hi_p, color = outcome),
    position = pd, height = 0.18, linewidth = 0.9
  ) +
  
  # Points
  geom_point(
    aes(fill = outcome, size = sig),
    shape = 21, color = "black", stroke = 0.35,
    position = pd, alpha = 0.95
  ) +
  
  # CI truncation arrows (Left)
  geom_segment(
    data = df_fp %>% filter(cut_left),
    aes(x = x_min * 1.35, xend = x_min * 1.08,
        y = term_label, yend = term_label, color = outcome),
    inherit.aes = FALSE,
    arrow = arrow(type = "closed", length = unit(0.16, "cm")),
    linewidth = 0.9
  ) +
  
  # CI truncation arrows (Right)
  geom_segment(
    data = df_fp %>% filter(cut_right),
    aes(x = x_max / 1.35, xend = x_max / 1.08,
        y = term_label, yend = term_label, color = outcome),
    inherit.aes = FALSE,
    arrow = arrow(type = "closed", length = unit(0.16, "cm")),
    linewidth = 0.9
  ) +
  
  scale_x_log10(
    limits = c(x_min, x_max), 
    expand = expansion(mult = c(0.05, 0)), 
    name = "Odds ratio (log scale)"
  ) +
  
  # parse=TRUE renders the atop() logic
  scale_y_discrete(labels = function(x) parse(text = x)) +
  
  scale_fill_manual(
    values = cols_outcome, 
    name = "Diagnosis"
  ) +
  scale_color_manual(
    values = cols_outcome, 
    name = "Diagnosis"
  ) +
  
  scale_size_continuous(
    name = expression(atop(-log[10](italic(p)), "(with 95% CI)")),
    range = c(2.6, 6.8) 
  ) +
  
  guides(
    color = "none",
    fill  = guide_legend(order = 1, override.aes = list(size = 5)),
    size  = guide_legend(order = 2)
  ) +
  
  theme_classic(base_size = 12) +
  theme(
    axis.title.y = element_blank(),
    axis.text.y = element_text(lineheight = 0.8),
    legend.position = c(0.99, 0.99),
    legend.justification = c(1, 1),
    legend.box = "horizontal",
    legend.box.just = "top",
    legend.spacing.x = unit(0.4, "cm"),
    legend.background = element_rect(fill = "white", colour = "grey70", linewidth = 0.4),
    legend.key = element_rect(fill = "white"),
    legend.title = element_text(size = 10),
    legend.text  = element_text(size = 9),
    
    plot.margin = margin(8, 20, 8, 8)
  )

print(g_forest)

ggsave(
  filename = file.path(fig_dir, "ATXN2_forest_plot.tiff"),
  plot = g_forest,
  device = "tiff",
  width = 500, height = 160, units = "mm",
  dpi = 600, compression = "lzw"
)
# FIGURE 2.2/3: Predicted probabilities vs allele size----
# --- Model & Data Setup
DT_plot <- DT_allele 
model_plot <- model_ATXN2_final

# 1. Define SEX levels
sex_levels <- levels(DT_plot$SEX)
if (length(sex_levels) < 2) stop("SEX must have at least 2 levels.")

# 2. Define AGE quantiles (P25, P50, P75)
age_q <- quantile(DT_plot$AGE, probs = c(0.25, 0.50, 0.75), na.rm = TRUE)
age_df <- tibble(
  AGE = as.numeric(age_q),
  age_group = factor(c("Age P25", "Age P50", "Age P75"),
                     levels = c("Age P25", "Age P50", "Age P75"))
)

# 3. Define allele medians (to hold the non-varying allele constant)
med_short <- median(DT_plot$ALLELE1_ATXN2, na.rm = TRUE)
med_long  <- median(DT_plot$ALLELE2_ATXN2, na.rm = TRUE)

# 4. Define APOE reference
if(is.factor(DT_plot$APOE_E4)) {
  ref_apoe <- levels(DT_plot$APOE_E4)[1] 
} else {
  ref_apoe <- "E4-"
}

# 5. Prediction Grids
grid_short <- seq(min(DT_plot$ALLELE1_ATXN2, na.rm = TRUE), 
                  max(DT_plot$ALLELE1_ATXN2, na.rm = TRUE), by = 0.05)
grid_long  <- seq(min(DT_plot$ALLELE2_ATXN2, na.rm = TRUE), 
                  max(DT_plot$ALLELE2_ATXN2, na.rm = TRUE), by = 0.05)

# --- Helper Function
predict_probs_long <- function(model, newdata) {
  pr <- as.data.frame(predict(model, newdata = newdata, type = "probs"))
  bind_cols(newdata, pr) %>%
    pivot_longer(
      cols = all_of(colnames(pr)),
      names_to = "outcome",
      values_to = "p"
    )
}

# FIGURE 2.2: VARY LONG ALLELE ----

# Create newdata
nd_long <- expand_grid(
  ALLELE2_ATXN2 = grid_long,
  SEX = factor(sex_levels, levels = sex_levels),
  age_df,
  APOE_E4 = ref_apoe
) %>%
  mutate(ALLELE1_ATXN2 = med_short)

# Predict
pred_long <- predict_probs_long(model_plot, nd_long) %>%
  filter(outcome %in% c("BD", "SCZ")) %>%
  mutate(outcome = factor(outcome, levels = c("BD", "SCZ")))

# Plot
p_long <- ggplot(pred_long, aes(x = ALLELE2_ATXN2, y = p, color = outcome, linetype = SEX)) +
  geom_line(linewidth = 0.9) +
  facet_wrap(~ age_group, nrow = 1) +
  
  scale_color_manual(values = cols_outcome, name = "Diagnosis") +
  scale_linetype_manual(values = c("solid", "dashed")[seq_along(sex_levels)], name = "Sex") +
  scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.25)) +
  
  labs(
    title = NULL,
    subtitle = NULL,
    x = expression(italic("ATXN2") ~ "long allele (CAG repeats)"), 
    y = "Predicted probability"
  ) +
  theme_classic(base_size = 12) +
  theme(
    legend.position = "top", 
    legend.box = "horizontal", 
    legend.key.width = unit(1.5, "cm"), 
    strip.background = element_rect(fill = "grey95", color = NA),
    strip.text = element_text(face = "bold")
  )

print(p_long)

ggsave(
  filename = file.path(fig_dir, "Predicted_probs_long_byAge.tiff"),
  plot = p_long,
  device = "tiff",
  width = 10, height = 5, units = "in", 
  dpi = 600, compression = "lzw"
)


# FIGURE 2.3: VARY SHORT ALLELE ----

# Create newdata
nd_short <- expand_grid(
  ALLELE1_ATXN2 = grid_short,
  SEX = factor(sex_levels, levels = sex_levels),
  age_df,
  APOE_E4 = ref_apoe
) %>%
  mutate(ALLELE2_ATXN2 = med_long)

# Predict
pred_short <- predict_probs_long(model_plot, nd_short) %>%
  filter(outcome %in% c("BD", "SCZ")) %>%
  mutate(outcome = factor(outcome, levels = c("BD", "SCZ")))

# Plot
p_short <- ggplot(pred_short, aes(x = ALLELE1_ATXN2, y = p, color = outcome, linetype = SEX)) +
  geom_line(linewidth = 0.9) +
  facet_wrap(~ age_group, nrow = 1) +
  
  scale_color_manual(values = cols_outcome, name = "Diagnosis") +
  scale_linetype_manual(values = c("solid", "dashed")[seq_along(sex_levels)], name = "Sex") +
  scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.25)) +
  
  labs(
    title = NULL,
    subtitle = NULL,
    x = expression(italic("ATXN2") ~ "short allele (CAG repeats)"),
    y = "Predicted probability"
  ) +
  theme_classic(base_size = 12) +
  theme(
    legend.position = "top", 
    legend.box = "horizontal",
    legend.key.width = unit(1.5, "cm"),
    strip.background = element_rect(fill = "grey95", color = NA),
    strip.text = element_text(face = "bold")
  )

print(p_short)

ggsave(
  filename = file.path(fig_dir, "Predicted_probs_short_byAge.tiff"),
  plot = p_short,
  device = "tiff",
  width = 10, height = 5, units = "in",
  dpi = 600, compression = "lzw"
)
# FIGURE 2: Layout Configuration ----
Figure_Composite <- 
  wrap_elements(g_forest) / 
  (p_short | p_long) +
  
  plot_layout(heights = c(1.3, 1)) + 
  
  plot_annotation(tag_levels = "A") & 
  
  theme(
    plot.tag = element_text(face = "bold", size = 20),
    plot.tag.position = c(0, 1), 
    plot.tag.padding = unit(5, "pt")
  )

# Preview
print(Figure_Composite)

# --- Save to File ---
ggsave(
  filename = file.path(fig_dir, "Figure_Composite_ATXN2.tiff"),
  plot = Figure_Composite,
  device = "tiff",
  width = 450, height = 400, units = "mm", 
  dpi = 600, compression = "lzw"
)

# 2. BINOMIAL MODELS: block-AIC selection + final per-gene models ======
# 1) Fit FULL model: covariates + gene blocks (each block: short + short^2 + long + long^2 + short:long)
# 2) Block-deletion AIC: remove each gene block from FULL and compare AIC (select best set by AIC)
# 3) (Optional) Greedy step-by-blocks: iteratively remove the gene whose removal improves AIC most
# 4) Fit FINAL per-gene models: covariates + one gene block (for each gene retained by selection)

# Helpers ----
drop_na_vars <- function(df, vars) {
  dplyr::filter(df, dplyr::if_all(dplyr::all_of(vars), ~ !is.na(.)))
}

ensure_factor_ref <- function(df, var, ref) {
  df[[var]] <- relevel(factor(df[[var]]), ref = ref)
  df
}

gene_block_string <- function(short, long) {
  paste0(
    short, " + I(", short, "^2) + ",
    long,  " + I(", long,  "^2) + ",
    short, ":", long
  )
}

make_formula <- function(outcome, covars, gene_blocks = character()) {
  rhs <- paste(covars, collapse = " + ")
  if (length(gene_blocks) > 0) rhs <- paste(rhs, paste(gene_blocks, collapse = " + "), sep = " + ")
  stats::as.formula(paste0(outcome, " ~ ", rhs))
}

fit_glm_binom <- function(df, formula) {
  stats::glm(formula, data = df, family = stats::binomial())
}

# Core function ----
fit_binomial_blockAIC <- function(df,
                                  outcome,
                                  covars,
                                  genes,
                                  outcome_ref = NULL,     # e.g., "BD"
                                  do_greedy = TRUE,       # greedy elimination of gene blocks
                                  keep_within_2AIC = FALSE,
                                  verbose = TRUE) {
  stopifnot(is.data.frame(df))
  stopifnot(all(c(outcome, covars) %in% names(df)))
  stopifnot(is.list(genes), length(genes) >= 1)
  
  # outcome as factor with chosen reference (important for interpretation)
  if (!is.null(outcome_ref)) df <- ensure_factor_ref(df, outcome, outcome_ref)
  df[[outcome]] <- factor(df[[outcome]])
  
  # common covariates as factors when present (keeps consistent with your pipeline)
  for (v in intersect(c("SEX", "COFFEE", "SMOKER", "APOE_E4"), c(outcome, covars))) {
    df[[v]] <- factor(df[[v]])
  }
  
  # Build gene block strings
  gene_names <- names(genes)
  if (is.null(gene_names) || any(gene_names == "")) {
    stop("genes must be a *named* list, e.g. list(HTT=c('ALLELE1_HTT','ALLELE2_HTT'), ...)")
  }
  gene_blocks <- purrr::imap_chr(genes, ~ gene_block_string(.x[1], .x[2]))
  
  # Complete-case for all vars used by FULL model
  allele_vars <- unique(unlist(genes))
  needed <- unique(c(outcome, covars, allele_vars))
  d <- drop_na_vars(df, needed)
  
  # FULL + NULL
  f_null <- make_formula(outcome, covars, gene_blocks = character())
  f_full <- make_formula(outcome, covars, gene_blocks = gene_blocks)
  
  m_null <- fit_glm_binom(d, f_null)
  m_full <- fit_glm_binom(d, f_full)
  
  # One-step block deletion (FULL minus each gene)
  del_tbl <- purrr::imap_dfr(gene_blocks, function(block, gname) {
    kept <- gene_blocks[setdiff(names(gene_blocks), gname)]
    f <- make_formula(outcome, covars, gene_blocks = kept)
    m <- fit_glm_binom(d, f)
    tibble::tibble(
      candidate = paste0("Full - ", gname),
      removed_gene = gname,
      k_genes = length(kept),
      AIC = stats::AIC(m)
    )
  })
  
  base_tbl <- tibble::tibble(
    candidate = c("Null (covars only)", "Full (all genes)"),
    removed_gene = c(NA_character_, NA_character_),
    k_genes = c(0L, length(gene_blocks)),
    AIC = c(stats::AIC(m_null), stats::AIC(m_full))
  )
  
  aic_once <- dplyr::bind_rows(base_tbl, del_tbl) %>%
    dplyr::mutate(delta_AIC = AIC - min(AIC)) %>%
    dplyr::arrange(AIC)
  
  # Greedy elimination: iteratively drop the single gene whose removal reduces AIC the most
  greedy_path <- NULL
  best_genes <- names(gene_blocks)
  best_model <- m_full
  best_aic <- stats::AIC(m_full)
  
  if (isTRUE(do_greedy)) {
    current_genes <- names(gene_blocks)
    current_blocks <- gene_blocks
    current_model <- m_full
    current_aic <- best_aic
    
    step_i <- 0L
    greedy_path <- tibble::tibble(
      step = step_i,
      action = "start",
      genes = paste(current_genes, collapse = ","),
      k_genes = length(current_genes),
      AIC = current_aic
    )
    
    repeat {
      if (length(current_genes) == 0) break
      
      # evaluate dropping each remaining gene
      candidates <- purrr::map_dfr(current_genes, function(g) {
        kept_genes <- setdiff(current_genes, g)
        kept_blocks <- current_blocks[kept_genes]
        f <- make_formula(outcome, covars, gene_blocks = kept_blocks)
        m <- fit_glm_binom(d, f)
        tibble::tibble(drop = g, AIC = stats::AIC(m))
      }) %>% dplyr::arrange(AIC)
      
      # pick best drop
      best_drop <- candidates$drop[1]
      best_drop_aic <- candidates$AIC[1]
      
      # stop if not improving
      if (!(best_drop_aic + 1e-8 < current_aic)) break
      
      # apply drop
      current_genes <- setdiff(current_genes, best_drop)
      current_blocks <- current_blocks[current_genes]
      current_aic <- best_drop_aic
      current_model <- fit_glm_binom(d, make_formula(outcome, covars, current_blocks))
      
      step_i <- step_i + 1L
      greedy_path <- dplyr::bind_rows(
        greedy_path,
        tibble::tibble(
          step = step_i,
          action = paste0("drop ", best_drop),
          genes = if (length(current_genes) > 0) paste(current_genes, collapse = ",") else "",
          k_genes = length(current_genes),
          AIC = current_aic
        )
      )
      
      # record best
      if (current_aic < best_aic) {
        best_aic <- current_aic
        best_genes <- current_genes
        best_model <- current_model
      }
    }
  }
  
  # Option: keep simplest within 2 AIC of best (from greedy end-models if available)
  if (isTRUE(keep_within_2AIC) && !is.null(greedy_path)) {
    minA <- min(greedy_path$AIC, na.rm = TRUE)
    candidates <- greedy_path %>% dplyr::filter(AIC <= minA + 2) %>% dplyr::arrange(k_genes, AIC)
    chosen <- candidates[1, , drop = FALSE]
    best_genes <- if (chosen$genes == "") character() else strsplit(chosen$genes, ",", fixed = TRUE)[[1]]
    best_model <- fit_glm_binom(d, make_formula(outcome, covars, gene_blocks[best_genes]))
    best_aic <- stats::AIC(best_model)
  }
  
  # Final per-gene models (covars + single gene block) for genes retained
  final_gene_models <- NULL
  final_gene_tidy <- NULL
  
  if (length(best_genes) > 0) {
    final_gene_models <- purrr::imap(genes[best_genes], function(pair, gname) {
      f <- make_formula(outcome, covars, gene_blocks = gene_block_string(pair[1], pair[2]))
      fit_glm_binom(d, f)
    })
    final_gene_tidy <- purrr::imap(final_gene_models, ~ broom::tidy(.x, exponentiate = TRUE, conf.int = TRUE))
  } else {
    final_gene_models <- list()
    final_gene_tidy <- list()
  }
  
  if (isTRUE(verbose)) {
    cat("\n# Block-deletion AIC (one-step):\n")
    print(aic_once)
    if (!is.null(greedy_path)) {
      cat("\n# Greedy block-step path:\n")
      print(greedy_path)
    }
    cat("\n# Selected genes:\n")
    print(best_genes)
    cat("\n# Selected model AIC:\n")
    print(best_aic)
  }
  
  list(
    data = d,
    formulas = list(null = f_null, full = f_full),
    models = list(null = m_null, full = m_full, selected = best_model),
    aic_once = aic_once,
    greedy_path = greedy_path,
    selected_genes = best_genes,
    final_gene_models = final_gene_models,
    final_gene_tidy = final_gene_tidy
  )
}

# 2.1 (BD vs SCZ) ======
genes <- list(
  HTT   = c("ALLELE1_HTT",  "ALLELE2_HTT"),
  ATXN1 = c("ALLELE1_ATXN1", "ALLELE2_ATXN1"),
  ATXN2 = c("ALLELE1_ATXN2", "ALLELE2_ATXN2")
)

covars_dx <- c("SEX","AGE","COFFEE","SMOKER","APOE_E4")

res_dx <- fit_binomial_blockAIC(
  df = MENTAL,
  outcome = "PATHOLOGY",
  outcome_ref = "BD",
  covars = covars_dx,
  genes = genes,
  do_greedy = TRUE,
  keep_within_2AIC = TRUE,
  verbose = TRUE
)

# # Final per-gene models (only for selected genes)
res_dx$final_gene_models
res_dx$final_gene_tidy


# 2.2 (CD in BD) ======
res_dx <- fit_binomial_blockAIC(
  df = BD,
  outcome = "CD_BINARY",
  outcome_ref = "CD",
  covars = covars_dx,
  genes = genes,
  do_greedy = TRUE,
  keep_within_2AIC = TRUE,
  verbose = TRUE
)

# # Final per-gene models (only for selected genes)
res_dx$final_gene_models
res_dx$final_gene_tidy

# 2.3 (CD in SCZ) ======
res_dx <- fit_binomial_blockAIC(
  df = SCZ,
  outcome = "CD_BINARY",
  outcome_ref = "CD",
  covars = covars_dx,
  genes = genes,
  do_greedy = TRUE,
  keep_within_2AIC = TRUE,
  verbose = TRUE
)

# # Final per-gene models (only for selected genes)
res_dx$final_gene_models
res_dx$final_gene_tidy

# 2.4 (TYPE in BD) ======
res_dx <- fit_binomial_blockAIC(
  df = BD,
  outcome = "PATHOLOGY_TYPE_BINARY",
  outcome_ref = "BD-I",
  covars = covars_dx,
  genes = genes,
  do_greedy = TRUE,
  keep_within_2AIC = TRUE,
  verbose = TRUE
)

# # Final per-gene models (only for selected genes)
res_dx$final_gene_models
res_dx$final_gene_tidy

# 2.5 (TYPE in SCZ) ======
res_dx <- fit_binomial_blockAIC(
  df = SCZ,
  outcome = "PATHOLOGY_TYPE_BINARY",
  outcome_ref = "SCZ",
  covars = covars_dx,
  genes = genes,
  do_greedy = TRUE,
  keep_within_2AIC = TRUE,
  verbose = TRUE
)

# # Final per-gene models (only for selected genes)
res_dx$final_gene_models
res_dx$final_gene_tidy

# Session info ----
sessionInfo()
```

## 06_Survival_Age_analysis.R

This script evaluates the association between STR-based genotype classifications (HTT_CODE, SCA1_CODE, SCA2_CODE) and clinical variables (age at onset, disease duration) in schizophrenia (SCH) and bipolar disorder (BD) patients. Analyses include subgroup comparisons within BD (e.g., BD-I, BD-CD) and survival models.

```{r}
# Subsetting by BD-I and CD
BD_I <- subset(BD, BD$PATHOLOGY_TYPE_BINARY == "BD-I")
BD_II <- subset(BD, BD$BD_type == "TBP2")
BD_CD <- subset(BD, BD$CD_BINARY == "CD")
BD_NOCD <- subset(BD, BD$CD_BINARY == "No-CD")

# Subsetting by CD in SCZ
SCZ_P <- subset(SCZ, SCZ$PATHOLOGY_TYPE_BINARY == "SCZ")
SCZ_CD <- subset(SCZ, SCZ$CD_BINARY == "CD")
SCZ_NOCD <- subset(SCZ, SCZ$CD_BINARY == "No-CD")

#CORRELATION TESTS ----
cor.test(BD$ONSET_AGE,BD$DURATION,method = "spearman")
cor.test(SCZ$ONSET_AGE,SCZ$DURATION,method = "spearman")

# Sup. Fig. 2A: Correlation plots (BD and SCZ) ----
cols_outcome <- c("BD" = "#8CBDE6", "SCZ" = "#F5A04D")

make_cor_panel <- function(df, group = c("BD", "SCZ"),
                           x = "ONSET_AGE", y = "DURATION",
                           title = "") {
  group <- match.arg(group)
  col_use <- cols_outcome[group]
  
  d <- df %>%
    dplyr::select(all_of(c(x, y))) %>%
    dplyr::filter(!is.na(.data[[x]]), !is.na(.data[[y]]))
  
  ggplot(d, aes(x = .data[[x]], y = .data[[y]])) +
    # CI in group color (only ribbon)
    geom_smooth(method = "lm", se = TRUE, aes(fill = col_use),
                color = "black", linewidth = 0.9, alpha = 0.35) +
    # Points: filled by group color + black border
    geom_point(shape = 20, fill = "black", color = "black",
               stroke = 0.35, size = 2, alpha = 0.85) +
    # Correlation text (Spearman)
    stat_cor(method = "spearman", label.x.npc = "middle", label.y.npc = "top") +
    labs(
      x = "Age at onset (years)",
      y = "Disease duration (years)",
      title = title
    ) +
    theme_classic(base_size = 12) +
    theme(plot.title = element_text(hjust = 0.5)) +
    scale_fill_identity()
}

pA_BD  <- make_cor_panel(BD,  group = "BD",  title = "Bipolar disorder")
pA_SCZ <- make_cor_panel(SCZ, group = "SCZ", title = "Schizophrenia")

# Optional: same axes for comparability
#xlim_all <- range(c(BD$ONSET_AGE, SCZ$ONSET_AGE), na.rm = TRUE)
#ylim_all <- range(c(BD$DURATION,  SCZ$DURATION),  na.rm = TRUE)

#pA_BD  <- pA_BD  + coord_cartesian(xlim = xlim_all, ylim = ylim_all)
#pA_SCZ <- pA_SCZ + coord_cartesian(xlim = xlim_all, ylim = ylim_all)

panel_A <- ggarrange(pA_BD, pA_SCZ, ncol = 2, align = "hv")
panel_A
ggsave(
  filename = file.path(fig_dir, "Sup_Fig_2A.tiff"),
  plot = panel_A,
  device = "tiff",
  width = 500, height = 160, units = "mm",
  dpi = 600, compression = "lzw"
)
# 1. AGE AT ONSET - DISEASE DURATION CORRELATIONS ----

# BD - HTT
mean_sd(BD, "HTT_CODE", "ONSET_AGE", "Age at onset BD")
kruskal.test(ONSET_AGE ~ HTT_CODE, data = BD)
dunn <- dunnTest(BD$ONSET_AGE ~ BD$HTT_CODE, method = "holm")
print(dunn, dunn.test.results = TRUE)

mean_sd(BD_I, "HTT_CODE", "ONSET_AGE", "Age at onset BD-I")
kruskal.test(ONSET_AGE ~ HTT_CODE, data = BD_I)
dunn <- dunnTest(BD_I$ONSET_AGE ~ BD_I$HTT_CODE, method = "holm")
print(dunn, dunn.test.results = TRUE)

mean_sd(BD_CD, "HTT_CODE", "ONSET_AGE", "Age at onset BD-CD")
kruskal.test(ONSET_AGE ~ HTT_CODE, data = BD_CD)

mean_sd(BD_NOCD, "HTT_CODE", "ONSET_AGE", "Age at onset BD-NO-CD")
kruskal.test(ONSET_AGE ~ HTT_CODE, data = BD_NOCD)

# SCZ - HTT
mean_sd(SCZ, "HTT_CODE", "ONSET_AGE", "Age at onset SCZ")
wilcox.test(ONSET_AGE ~ HTT_CODE, data = SCZ)

mean_sd(SCZ_P, "HTT_CODE", "ONSET_AGE", "Age at onset SCZ_P")
kruskal.test(ONSET_AGE ~ HTT_CODE, data = SCZ_P)

mean_sd(SCZ_CD, "HTT_CODE", "ONSET_AGE", "Age at onset SCZ_CD")
kruskal.test(ONSET_AGE ~ HTT_CODE, data = SCZ_CD)

mean_sd(SCZ_NOCD, "HTT_CODE", "ONSET_AGE", "Age at onset SCZ_NOCD")
kruskal.test(ONSET_AGE ~ HTT_CODE, data = SCZ_NOCD)

# BD - ATXN1
mean_sd(BD, "ATXN1_CODE", "ONSET_AGE", "Age at onset BD")
wilcox.test(ONSET_AGE ~ ATXN1_CODE, data = BD)

mean_sd(BD_I, "ATXN1_CODE", "ONSET_AGE", "Age at onset BD-I")
kruskal.test(ONSET_AGE ~ ATXN1_CODE, data = BD_I)

mean_sd(BD_CD, "ATXN1_CODE", "ONSET_AGE", "Age at onset BD-CD")
kruskal.test(ONSET_AGE ~ ATXN1_CODE, data = BD_CD)

mean_sd(BD_NOCD, "ATXN1_CODE", "ONSET_AGE", "Age at onset BD-NO-CD")
kruskal.test(ONSET_AGE ~ ATXN1_CODE, data = BD_NOCD)

# SCZ - ATXN1
mean_sd(SCZ, "ATXN1_CODE", "ONSET_AGE", "Age at onset SCZ")
wilcox.test(ONSET_AGE ~ ATXN1_CODE, data = SCZ)

mean_sd(SCZ_P, "ATXN1_CODE", "ONSET_AGE", "Age at onset SCZ_P")
kruskal.test(ONSET_AGE ~ ATXN1_CODE, data = SCZ_P)

mean_sd(SCZ_CD, "ATXN1_CODE", "ONSET_AGE", "Age at onset SCZ_CD")
kruskal.test(ONSET_AGE ~ ATXN1_CODE, data = SCZ_CD)

mean_sd(SCZ_NOCD, "ATXN1_CODE", "ONSET_AGE", "Age at onset SCZ_NOCD")
kruskal.test(ONSET_AGE ~ ATXN1_CODE, data = SCZ_NOCD)

# BD - ATXN2
mean_sd(BD, "ATXN2_CODE", "ONSET_AGE", "Age at onset BD")
wilcox.test(ONSET_AGE ~ ATXN2_CODE, data = BD)

mean_sd(BD_I, "ATXN2_CODE", "ONSET_AGE", "Age at onset BD-I")
wilcox.test(ONSET_AGE ~ ATXN2_CODE, data = BD_I)

mean_sd(BD_CD, "ATXN2_CODE", "ONSET_AGE", "Age at onset BD-CD")
wilcox.test(ONSET_AGE ~ ATXN2_CODE, data = BD_CD)

mean_sd(BD_NOCD, "ATXN2_CODE", "ONSET_AGE", "Age at onset BD-NO-CD")
kruskal.test(ONSET_AGE ~ ATXN2_CODE, data = BD_NOCD)

# SCZ - ATXN2
mean_sd(SCZ, "ATXN2_CODE", "ONSET_AGE", "Age at onset SCZ")
kruskal.test(ONSET_AGE ~ ATXN2_CODE, data = SCZ)

mean_sd(SCZ_P, "ATXN2_CODE", "ONSET_AGE", "Age at onset SCZ_P")
kruskal.test(ONSET_AGE ~ ATXN2_CODE, data = SCZ_P)

mean_sd(SCZ_CD, "ATXN2_CODE", "ONSET_AGE", "Age at onset SCZ_CD")
kruskal.test(ONSET_AGE ~ ATXN2_CODE, data = SCZ_CD)

mean_sd(SCZ_NOCD, "ATXN2_CODE", "ONSET_AGE", "Age at onset SCZ_NOCD")
kruskal.test(ONSET_AGE ~ ATXN2_CODE, data = SCZ_NOCD)

#BD APOE

mean_sd(BD, "APOE_E4", "ONSET_AGE", "Age at onset APOE E4")
wilcox.test(ONSET_AGE ~ APOE_E4, data = BD)
rank_biserial(ONSET_AGE ~ APOE_E4, data = BD)

mean_sd(BD_I, "APOE_E4", "ONSET_AGE", "Age at onset BD-I")
wilcox.test(ONSET_AGE ~ APOE_E4, data = BD_I)
rank_biserial(ONSET_AGE ~ APOE_E4, data = BD_I)

mean_sd(BD_II, "APOE_E4", "DURATION", "Duration BD_II")
wilcox.test(ONSET_AGE ~ APOE_E4, data = BD_II)
rank_biserial(ONSET_AGE ~ APOE_E4, data = BD_II)

mean_sd(BD_CD, "APOE_E4", "ONSET_AGE", "Age at onset BD-CD")
wilcox.test(ONSET_AGE ~ APOE_E4, data = BD_CD)
rank_biserial(ONSET_AGE ~ APOE_E4, data = BD_CD)

mean_sd(BD_NOCD, "APOE_E4", "ONSET_AGE", "Age at onset BD-NO-CD")
wilcox.test(ONSET_AGE ~ APOE_E4, data = BD_NOCD)
rank_biserial(ONSET_AGE ~ APOE_E4, data = BD_NOCD)

#SCZ APOE
mean_sd(SCZ, "APOE_E4", "ONSET_AGE", "Age at onset SCZ")
wilcox.test(ONSET_AGE ~ APOE_E4, data = SCZ)
rank_biserial(ONSET_AGE ~ APOE_E4, data = SCZ)

mean_sd(SCZ_P, "APOE_E4", "ONSET_AGE", "Age at onset SCZ_P")
wilcox.test(ONSET_AGE ~ APOE_E4, data = SCZ_P)
rank_biserial(ONSET_AGE ~ APOE_E4, data = SCZ_P)

mean_sd(SCZ_CD, "APOE_E4", "ONSET_AGE", "Age at onset SCZ_CD")
wilcox.test(ONSET_AGE ~ APOE_E4, data = SCZ_CD)
rank_biserial(ONSET_AGE ~ APOE_E4, data = SCZ_CD)

mean_sd(SCZ_NOCD, "APOE_E4", "ONSET_AGE", "Age at onset SCZ_NOCD")
wilcox.test(ONSET_AGE ~ APOE_E4, data = SCZ_NOCD)
rank_biserial(ONSET_AGE ~ APOE_E4, data = SCZ_NOCD)
# 2. AGE-OF-ONSET MODELING ----
# Linear  models within BD and within SCZ.
# Genes: HTT, ATXN1, ATXN2
#
# For EACH model:
#   - Full model: covariates + genetic block (linear + quadratic + interaction)
#   - Null model: covariates only (always retained)
#   - Global test of genetic block: nested-model ANOVA (F-test)
#   - AIC + delta AIC
#   - Optional stepwise backward selection (exploratory) restricted to genetics
#
# IMPORTANT:
#   - Do NOT use exponentiate=TRUE for lm() (no ORs here).
#   - Report p-values for genetic terms or for the global F-test (full vs null).

# - 2.1 Full model Age of onset and IA: fit + step only genes -----
fit_onset_step_genes <- function(df,
                                 outcome = "ONSET_AGE",
                                 covars = c("SEX","COFFEE","SMOKER","APOE_E4"),
                                 genes  = c("HTT_CODE","ATXN1_CODE","ATXN2_CODE")) {
  
  vars_needed <- c(outcome, covars, genes)
  
  d <- df %>%
    dplyr::select(all_of(vars_needed)) %>%
    dplyr::filter(if_all(everything(), ~ !is.na(.))) %>%
    dplyr::mutate(
      SEX      = droplevels(factor(SEX)),
      COFFEE   = droplevels(factor(COFFEE)),
      SMOKER   = droplevels(factor(SMOKER)),
      HTT_CODE = droplevels(factor(HTT_CODE)),
      ATXN1_CODE= droplevels(factor(ATXN1_CODE)),
      ATXN2_CODE= droplevels(factor(ATXN2_CODE))
    )
  
  f_lower <- as.formula(paste(outcome, "~", paste(covars, collapse = " + ")))
  f_upper <- as.formula(paste(outcome, "~", paste(c(covars, genes), collapse = " + ")))
  
  m_full  <- lm(f_upper, data = d)
  
  # Backward step restricted to genes: cannot drop covariates
  m_step <- step(
    object    = m_full,
    scope     = list(lower = f_lower, upper = f_upper),
    direction = "backward",
    trace     = 0
  )
  
  list(
    data = d,
    full = m_full,
    step = m_step,
    AIC  = AIC(m_full, m_step)
  )
}

# BD
res_BD  <- fit_onset_step_genes(df = BD)
summary(res_BD$step)
res_BD$AIC

res_BD_CD  <- fit_onset_step_genes(df = BD_CD)
summary(res_BD_CD$step)
res_BD_CD$AIC

# SCZ
res_SCZ <- fit_onset_step_genes(df = SCZ)
summary(res_SCZ$step)
res_SCZ$AIC

res_SCZ_CD  <- fit_onset_step_genes(df = SCZ_CD)
summary(res_SCZ_CD$step)
res_SCZ_CD$AIC

# - 2.2 Full model Age of onset and CAG repeats: fit + step only genes -----

drop_na <- function(df, vars) df %>% filter(if_all(all_of(vars), ~ !is.na(.)))

block_terms <- function(s, l) c(
  s, paste0("I(", s, "^2)"),
  l, paste0("I(", l, "^2)"),
  paste0(s, ":", l)
)

enforce_block_hierarchy <- function(keep, s, l) {
  qs <- paste0("I(", s, "^2)")
  ql <- paste0("I(", l, "^2)")
  it <- paste0(s, ":", l)
  
  keep <- unique(keep)
  if (qs %in% keep && !(s %in% keep)) keep <- c(keep, s)
  if (ql %in% keep && !(l %in% keep)) keep <- c(keep, l)
  if (it %in% keep) keep <- unique(c(keep, s, l))
  unique(keep)
}

fit_onset_multiblock <- function(df, outcome, covars, blocks_named, do_step = TRUE) {
  
  # factors for covars if present
  for (v in intersect(covars, names(df))) df[[v]] <- factor(df[[v]])
  
  # vars needed
  gene_vars <- unlist(lapply(blocks_named, \(b) c(b$short, b$long)))
  d <- drop_na(df, unique(c(outcome, covars, gene_vars)))
  
  # formulas
  block_rhs <- unlist(lapply(blocks_named, \(b) block_terms(b$short, b$long)))
  f_null <- as.formula(paste(outcome, "~", paste(covars, collapse = " + ")))
  f_full <- as.formula(paste(outcome, "~", paste(c(covars, block_rhs), collapse = " + ")))
  
  m_null <- lm(f_null, data = d)
  m_full <- lm(f_full, data = d)
  
  out <- list(
    data = d,
    null = m_null,
    full = m_full,
    an_full_vs_null = anova(m_null, m_full),
    step = NULL,
    an_step_vs_null = NULL
  )
  
  if (!isTRUE(do_step)) return(out)
  
  # step: only allow removing gene terms (covars fixed by scope lower)
  m_step_raw <- step(m_full, scope = list(lower = f_null, upper = f_full),
                     direction = "backward", trace = 0)
  sel <- attr(terms(m_step_raw), "term.labels")
  
  # keep covars always
  gene_all <- unique(block_rhs)
  gen_sel <- sel[sel %in% gene_all]
  
  # hierarchy per block
  gen_sel_h <- gen_sel
  for (b in blocks_named) gen_sel_h <- enforce_block_hierarchy(gen_sel_h, b$short, b$long)
  
  rhs <- c(covars, gen_sel_h)
  f_step <- as.formula(paste(outcome, "~", paste(rhs, collapse = " + ")))
  m_step <- lm(f_step, data = d)
  
  out$step <- m_step
  out$an_step_vs_null <- anova(m_null, m_step)
  out
}

# BD
blocks <- list(
  HTT  = list(short="ALLELE1_HTT",  long="ALLELE2_HTT"),
  ATXN1= list(short="ALLELE1_ATXN1", long="ALLELE2_ATXN1"),
  ATXN2= list(short="ALLELE1_ATXN2", long="ALLELE2_ATXN2")
)
covars_onset<-c("SEX","COFFEE","SMOKER","APOE_E4")

res_BD <- fit_onset_multiblock(BD, "ONSET_AGE", covars_onset, blocks, do_step = TRUE)

res_BD$an_full_vs_null
res_BD$an_step_vs_null
summary(res_BD$step)

#ATXN1 final model
f_atxn1 <- as.formula(paste(
  "ONSET_AGE ~", paste(covars_onset, collapse=" + "), "+",
  paste(block_terms("ALLELE1_ATXN1","ALLELE2_ATXN1"), collapse=" + ")
))
m_atxn1_BD <- lm(f_atxn1, data = drop_na(BD, c("ONSET_AGE", covars_onset, "ALLELE1_ATXN1","ALLELE2_ATXN1")))
anova(lm(as.formula(paste("ONSET_AGE ~", paste(covars_onset, collapse=" + "))), data = model.frame(m_atxn1_BD)),
      m_atxn1_BD)
summary(m_atxn1_BD)

# SCZ

res_SCZ <- fit_onset_multiblock(SCZ, "ONSET_AGE", covars_onset, blocks, do_step = TRUE)

res_SCZ$an_full_vs_null
res_SCZ$an_step_vs_null
summary(res_SCZ$step)

#ATXN1 final model
f_atxn1 <- as.formula(paste(
  "ONSET_AGE ~", paste(covars_onset, collapse=" + "), "+",
  paste(block_terms("ALLELE1_ATXN1","ALLELE2_ATXN1"), collapse=" + ")
))
m_atxn1_SCZ <- lm(f_atxn1, data = drop_na(SCZ, c("ONSET_AGE", covars_onset, "ALLELE1_ATXN1","ALLELE2_ATXN1")))
anova(lm(as.formula(paste("ONSET_AGE ~", paste(covars_onset, collapse=" + "))), data = model.frame(m_atxn1_SCZ)),
      m_atxn1_SCZ)
summary(m_atxn1_SCZ)

#Sup. Fig. 2B : Age of onset in BD vs ATXN1 ----
# Two clearly separated BD blues (light vs dark)
col_long <- c(
  "Normal (<33)"         = "#8CBDE6",  # light BD blue
  "Intermediate (33–38)" = "#163A5F"   # dark BD blue
)

# References (fixed values used for predictions)
ref_SEX    <- "Female"
ref_COFFEE <- "Coffee"
ref_SMOKER <- "Smoking"

# ---- Data prep 
BD_atxn1 <- BD %>%
  dplyr::select(
    ONSET_AGE, SEX, COFFEE, SMOKER,
    ALLELE1_ATXN1, ALLELE2_ATXN1
  ) %>%
  dplyr::filter(
    !is.na(ONSET_AGE),
    !is.na(SEX), !is.na(COFFEE), !is.na(SMOKER),
    !is.na(ALLELE1_ATXN1), !is.na(ALLELE2_ATXN1)
  ) %>%
  mutate(
    SEX    = factor(SEX),
    COFFEE = factor(COFFEE),
    SMOKER = factor(SMOKER),
    long_bin = case_when(
      ALLELE2_ATXN1 < 33 ~ "Normal (<33)",
      ALLELE2_ATXN1 >= 33 & ALLELE2_ATXN1 <= 38 ~ "Intermediate (33–38)",
      TRUE ~ NA_character_
    ),
    long_bin = factor(long_bin, levels = c("Normal (<33)", "Intermediate (33–38)"))
  ) %>%
  filter(!is.na(long_bin))

# ---- Model (as in your step-selected structure for ATXN1)
m_atxn1 <- lm(
  ONSET_AGE ~ SEX + COFFEE + SMOKER +
    ALLELE1_ATXN1 + I(ALLELE1_ATXN1^2) +
    ALLELE2_ATXN1 + I(ALLELE2_ATXN1^2) +
    ALLELE1_ATXN1:ALLELE2_ATXN1,
  data = BD_atxn1
)

# ---- Prediction grid over OBSERVED short-allele range
x_min_data <- min(BD_atxn1$ALLELE1_ATXN1, na.rm = TRUE)
x_max_data <- max(BD_atxn1$ALLELE1_ATXN1, na.rm = TRUE)
x_grid <- seq(x_min_data, x_max_data, by = 0.05)

# Representative long-allele value per bin (median within bin)
bin_reps <- BD_atxn1 %>%
  group_by(long_bin) %>%
  summarise(long_rep = median(ALLELE2_ATXN1, na.rm = TRUE), .groups = "drop")

# Baseline for centering (median alleles in the data)
a1_ref <- as.numeric(median(BD_atxn1$ALLELE1_ATXN1, na.rm = TRUE))
a2_ref <- as.numeric(median(BD_atxn1$ALLELE2_ATXN1, na.rm = TRUE))

# Build newdata for prediction
newdat <- expand.grid(
  ALLELE1_ATXN1 = x_grid,
  long_bin = levels(BD_atxn1$long_bin),
  stringsAsFactors = FALSE
) %>%
  left_join(bin_reps, by = "long_bin") %>%
  mutate(
    ALLELE2_ATXN1 = long_rep,
    SEX    = factor(ref_SEX,    levels = levels(BD_atxn1$SEX)),
    COFFEE = factor(ref_COFFEE, levels = levels(BD_atxn1$COFFEE)),
    SMOKER = factor(ref_SMOKER, levels = levels(BD_atxn1$SMOKER))
  )

# Predict + SE
pred <- predict(m_atxn1, newdata = newdat, se.fit = TRUE)
newdat$fit <- as.numeric(pred$fit)
newdat$se  <- as.numeric(pred$se.fit)

# Baseline prediction used to center y-axis
base_dat <- data.frame(
  ALLELE1_ATXN1 = a1_ref,
  ALLELE2_ATXN1 = a2_ref,
  SEX    = factor(ref_SEX,    levels = levels(BD_atxn1$SEX)),
  COFFEE = factor(ref_COFFEE, levels = levels(BD_atxn1$COFFEE)),
  SMOKER = factor(ref_SMOKER, levels = levels(BD_atxn1$SMOKER))
)
base_fit <- as.numeric(predict(m_atxn1, newdata = base_dat))

# Centered effects (delta) + centered CI
newdat <- newdat %>%
  mutate(
    delta = fit - base_fit,
    lo = (fit - 1.96 * se) - base_fit,
    hi = (fit + 1.96 * se) - base_fit
  )

# ---- Plot (single legend: fill drives legend; linetype legend removed)
lt_map <- c("Normal (<33)" = "dashed", "Intermediate (33–38)" = "solid")

p_atxn1 <- ggplot() +
  # CI ribbons (colored by long-allele bin)
  geom_ribbon(
    data = newdat,
    aes(
      x = ALLELE1_ATXN1, ymin = lo, ymax = hi,
      fill = long_bin, group = long_bin
    ),
    alpha = 0.25,
    color = NA
  ) +
  # Model lines (black; linetype by bin)
  geom_line(
    data = newdat,
    aes(
      x = ALLELE1_ATXN1, y = delta,
      linetype = long_bin, group = long_bin
    ),
    color = "black",
    linewidth = 0.9
  ) +
  # Points (colored by bin; black border)
  geom_point(
    data = BD_atxn1,
    aes(
      x = ALLELE1_ATXN1,
      y = ONSET_AGE - base_fit,
      fill = long_bin
    ),
    shape = 21,
    color = "black",
    stroke = 0.25,
    alpha = 0.45,
    size = 1.6,
    position = position_jitter(width = 0.10, height = 0)
  ) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey55", linewidth = 0.6) +
  labs(
    #subtitle = paste0(
    #  "Y-axis shows the change in model-predicted age at onset relative to an individual with median alleles (short=", a1_ref,
    #  ", long=", a2_ref, "), female, with coffee intake, and somker."
    #),
    x = expression(italic("ATXN1") * " short allele (CAG repeats)"),
    y = "Change in predicted age at onset (years)",
    fill = expression(italic("ATXN1") * " long allele group")
  ) +
  scale_fill_manual(values = col_long) +
  scale_linetype_manual(values = lt_map) +
  # One legend only (fill). Keep linetype mapping but hide its guide.
  guides(
    linetype = "none",
    fill = guide_legend(
      title = expression(italic("ATXN1") * " long allele group"),
      override.aes = list(
        linetype = c("dashed", "solid"),
        color = "black"
      )
    )
  ) +
  coord_cartesian(
    xlim = c(x_min_data, x_max_data),
    ylim = c(-30, 60),
    clip = "on"
  ) +
  theme_classic(base_size = 12) +
  theme(
    legend.position = c(0.86, 0.82),
    legend.justification = c(1, 0),
    legend.background = element_rect(fill = "white", color = "grey80", linewidth = 0.3),
    legend.key = element_rect(fill = "white", color = NA),
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 9),
    plot.margin = margin(6, 6, 6, 6)
  )

p_atxn1

ggsave(
  filename = file.path(fig_dir, "Sup_Fig_2B.tiff"),
  plot = p_atxn1,
  device = "tiff",
  width = 180, height = 120, units = "mm",
  dpi = 600, compression = "lzw"
)


# 3. DURATION CORRELATIONS ----

# BD - HTT
mean_sd(BD, "HTT_CODE", "DURATION", "Duration BD")
kruskal.test(DURATION ~ HTT_CODE, data = BD)

mean_sd(BD_I, "HTT_CODE", "DURATION", "Duration BD-I")
kruskal.test(DURATION ~ HTT_CODE, data = BD_I)

mean_sd(BD_CD, "HTT_CODE", "DURATION", "Duration BD-CD")
kruskal.test(DURATION ~ HTT_CODE, data = BD_CD)

mean_sd(BD_NOCD, "HTT_CODE", "DURATION", "Duration BD-NO-CD")
kruskal.test(DURATION ~ HTT_CODE, data = BD_NOCD)

# SCZ - HTT
mean_sd(SCZ, "HTT_CODE", "DURATION", "Duration SCZ")
wilcox.test(DURATION ~ HTT_CODE, data = SCZ)

mean_sd(SCZ_P, "HTT_CODE", "DURATION", "Duration SCZ_P")
kruskal.test(DURATION ~ HTT_CODE, data = SCZ_P)

mean_sd(SCZ_CD, "HTT_CODE", "DURATION", "Duration SCZ-CD")
kruskal.test(DURATION ~ HTT_CODE, data = SCZ_CD)

mean_sd(SCZ_NOCD, "HTT_CODE", "DURATION", "Duration SCZ-NO-CD")
kruskal.test(DURATION ~ HTT_CODE, data = SCZ_NOCD)

# BD - ATXN1
mean_sd(BD, "ATXN1_CODE", "DURATION", "Duration BD")
wilcox.test(DURATION ~ ATXN1_CODE, data = BD)

mean_sd(BD_I, "ATXN1_CODE", "DURATION", "Duration BD-I")
kruskal.test(DURATION ~ ATXN1_CODE, data = BD_I)

mean_sd(BD_CD, "ATXN1_CODE", "DURATION", "Duration BD-CD")
kruskal.test(DURATION ~ ATXN1_CODE, data = BD_CD)

mean_sd(BD_NOCD, "ATXN1_CODE", "DURATION", "Duration BD-NO-CD")
kruskal.test(DURATION ~ ATXN1_CODE, data = BD_NOCD)

# SCZ - ATXN1
mean_sd(SCZ, "ATXN1_CODE", "DURATION", "Duration SCZ")
wilcox.test(DURATION ~ ATXN1_CODE, data = SCZ)

mean_sd(SCZ_P, "ATXN1_CODE", "DURATION", "Duration SCZ_P")
kruskal.test(DURATION ~ ATXN1_CODE, data = SCZ_P)

mean_sd(SCZ_CD, "ATXN1_CODE", "DURATION", "Duration SCZ-CD")
kruskal.test(DURATION ~ ATXN1_CODE, data = SCZ_CD)

mean_sd(SCZ_NOCD, "ATXN1_CODE", "DURATION", "Duration SCZ-NO-CD")
kruskal.test(DURATION ~ ATXN1_CODE, data = SCZ_NOCD)

# BD - ATXN2
mean_sd(BD, "ATXN2_CODE", "DURATION", "Duration BD")
wilcox.test(DURATION ~ ATXN2_CODE, data = BD)

mean_sd(BD_I, "ATXN2_CODE", "DURATION", "Duration BD-I")
wilcox.test(DURATION ~ ATXN2_CODE, data = BD_I)

mean_sd(BD_CD, "ATXN2_CODE", "DURATION", "Duration BD-CD")
wilcox.test(DURATION ~ ATXN2_CODE, data = BD_CD)

mean_sd(BD_NOCD, "ATXN2_CODE", "DURATION", "Duration BD-NoCD")
wilcox.test(DURATION ~ ATXN2_CODE, data = BD_NOCD)

# SCZ - ATXN2
mean_sd(SCZ, "ATXN2_CODE", "DURATION", "Duration SCZ")
kruskal.test(DURATION ~ ATXN2_CODE, data = SCZ)

mean_sd(SCZ_P, "ATXN2_CODE", "DURATION", "Duration SCZ_P")
kruskal.test(DURATION ~ ATXN2_CODE, data = SCZ_P)

mean_sd(SCZ_CD, "ATXN2_CODE", "DURATION", "Duration SCZ-CD")
kruskal.test(DURATION ~ ATXN2_CODE, data = SCZ_CD)

mean_sd(SCZ_NOCD, "ATXN2_CODE", "DURATION", "Duration SCZ-NO-CD")

# BD - APOE
mean_sd(BD, "APOE_E4", "DURATION", "Duration BD")
wilcox.test(DURATION ~ APOE_E4, data = BD)
rank_biserial(DURATION ~ APOE_E4, data = BD)

mean_sd(BD_I, "APOE_E4", "DURATION", "Duration BD-I")
wilcox.test(DURATION ~ APOE_E4, data = BD_I)
rank_biserial(DURATION ~ APOE_E4, data = BD_I)

mean_sd(BD_II, "APOE_E4", "DURATION", "Duration BD_II")
wilcox.test(DURATION ~ APOE_E4, data = BD_II)
rank_biserial(DURATION ~ APOE_E4, data = BD_II)

mean_sd(BD_CD, "APOE_E4", "DURATION", "Duration BD-CD")
wilcox.test(DURATION ~ APOE_E4, data = BD_CD)
rank_biserial(DURATION ~ APOE_E4, data = BD_CD)

mean_sd(BD_NOCD, "APOE_E4", "DURATION", "Duration BD-NoCD")
wilcox.test(DURATION ~ APOE_E4, data = BD_NOCD)
rank_biserial(DURATION ~ APOE_E4, data = BD_NOCD)

# SCZ - APOE
mean_sd(SCZ, "APOE_E4", "DURATION", "Duration SCZ")
wilcox.test(DURATION ~ APOE_E4, data = SCZ)
rank_biserial(DURATION ~ APOE_E4, data = SCZ)

mean_sd(SCZ_P, "APOE_E4", "DURATION", "Duration SCZ_P")
wilcox.test(DURATION ~ APOE_E4, data = SCZ_P)
rank_biserial(DURATION ~ APOE_E4, data = SCZ_P)

mean_sd(SCZ_CD, "APOE_E4", "DURATION", "Duration SCZ-CD")
wilcox.test(DURATION ~ APOE_E4, data = SCZ_CD)
rank_biserial(DURATION ~ APOE_E4, data = SCZ_CD)

mean_sd(SCZ_NOCD, "APOE_E4", "DURATION", "Duration SCZ-NO-CD")
wilcox.test(DURATION ~ APOE_E4, data = SCZ_CD)
rank_biserial(DURATION ~ APOE_E4, data = SCZ_CD)

# 4. SURVIVAL CURVES ----

# BD
surv_object <- Surv(time = BD$DURATION, event = rep(1, length(BD$DURATION)))
cox_model <- coxph(surv_object ~ SEX + SMOKER + COFFEE + APOE_E4 + ATXN2_CODE + HTT_CODE + ATXN1_CODE, data = BD)
summary(cox_model)

survdiff(surv_object ~ COFFEE, data = BD, rho = 0)
survdiff(surv_object ~ APOE_E4, data = BD, rho = 0)
survdiff(surv_object ~ SEX, data = BD, rho = 0)
survdiff(surv_object ~ SMOKER, data = BD, rho = 0)
survdiff(surv_object ~ ATXN2_CODE, data = BD, rho = 0)
cox_model <- coxph(surv_object ~ ATXN2_CODE, data = BD)
summary(cox_model)
survdiff(surv_object ~ HTT_CODE, data = BD, rho = 0)
survdiff(surv_object ~ ATXN1_CODE, data = BD, rho = 0)

surv_object <- Surv(time = BD_NOCD$DURATION, event = rep(1, length(BD_NOCD$DURATION)))
survdiff(surv_object ~ APOE_E4, data = BD_NOCD, rho = 0)
survdiff(surv_object ~ ATXN2_CODE, data = BD_NOCD, rho = 0)
survdiff(surv_object ~ HTT_CODE, data = BD_NOCD, rho = 0)
survdiff(surv_object ~ ATXN1_CODE, data = BD_NOCD, rho = 0)

surv_object <- Surv(time = BD_CD$DURATION, event = rep(1, length(BD_CD$DURATION)))
cox_model <- coxph(surv_object ~ SEX + SMOKER + COFFEE + APOE_E4 + ATXN2_CODE + HTT_CODE + ATXN1_CODE, data = BD_CD)
summary(cox_model)
survdiff(surv_object ~ ATXN2_CODE, data = BD_CD, rho = 0)
cox_model <- coxph(surv_object ~ ATXN2_CODE, data = BD_CD)
summary(cox_model)
survdiff(surv_object ~ APOE_E4, data = BD_CD, rho = 0)
survdiff(surv_object ~ HTT_CODE, data = BD_CD, rho = 0)
survdiff(surv_object ~ ATXN1_CODE, data = BD_CD, rho = 0)

# SCZ
surv_object <- Surv(time = SCZ$DURATION, event = rep(1, length(SCZ$DURATION)))
cox_model <- coxph(surv_object ~ SEX + SMOKER + COFFEE + APOE_E4 + ATXN2_CODE + HTT_CODE + ATXN1_CODE, data = SCZ)
summary(cox_model)
survdiff(surv_object ~ APOE_E4, data = SCZ, rho = 0)
survdiff(surv_object ~ SEX, data = SCZ, rho = 0)
survdiff(surv_object ~ SMOKER, data = SCZ, rho = 0)
survdiff(surv_object ~ ATXN2_CODE, data = SCZ, rho = 0)
survdiff(surv_object ~ HTT_CODE, data = SCZ, rho = 0)
survdiff(surv_object ~ ATXN1_CODE, data = SCZ, rho = 0)

surv_object <- Surv(time = SCZ_NOCD$DURATION, event = rep(1, length(SCZ_NOCD$DURATION)))
survdiff(surv_object ~ APOE_E4, data = SCZ_NOCD, rho = 0)
survdiff(surv_object ~ HTT_CODE, data = SCZ_NOCD, rho = 0)
survdiff(surv_object ~ ATXN1_CODE, data = SCZ_NOCD, rho = 0)

surv_object <- Surv(time = SCZ_CD$DURATION, event = rep(1, length(SCZ_CD$DURATION)))
survdiff(surv_object ~ APOE_E4, data = SCZ_CD, rho = 0)
survdiff(surv_object ~ ATXN2_CODE, data = SCZ_CD, rho = 0)
survdiff(surv_object ~ HTT_CODE, data = SCZ_CD, rho = 0)
survdiff(surv_object ~ ATXN1_CODE, data = SCZ_CD, rho = 0)

# Sup. Fig. 2C: Forest plot from Cox model (BD) -----
# 1) Prepare BD dataset
BD_cox <- BD %>%
  filter(
    !is.na(DURATION),
    !is.na(SEX),
    !is.na(SMOKER),
    !is.na(COFFEE),
    !is.na(ATXN2_CODE),
    !is.na(HTT_CODE),
    !is.na(ATXN1_CODE),
    ATXN2_CODE != "EXPANDED",
    HTT_CODE  != "EXPANDED"
  ) %>%
  mutate(
    SEX       = droplevels(factor(SEX)),
    SMOKER    = droplevels(factor(SMOKER)),
    HTT_CODE  = droplevels(factor(HTT_CODE)),
    ATXN1_CODE = droplevels(factor(ATXN1_CODE)),
    ATXN2_CODE = droplevels(factor(ATXN2_CODE))
  )

# 2) Survival object
surv_object <- Surv(time = BD_cox$DURATION, event = rep(1, nrow(BD_cox)))

# 3) Cox model
cox_model <- coxph(
  surv_object ~ SEX + SMOKER + COFFEE + APOE_E4 + ATXN2_CODE + HTT_CODE + ATXN1_CODE,
  data = BD_cox
)

# 4) Tidy results
tt <- broom::tidy(cox_model, exponentiate = TRUE, conf.int = TRUE) %>%
  filter(term != "(Intercept)")

# 5) Forest plot data
x_min <- 0.25
x_max <- 4.5

col_nsig <- "#8CBDE6"  # blue
col_sig  <- "#d62728"  # red

df_fp <- tt %>%
  mutate(
    term = stringr::str_trim(term),  # por si hay espacios raros
    term_label = case_when(
      term == "SEX[T.Female]"          ~ "Female sex",
      term == "SMOKER[T.Non-smoking]"  ~ "Non-smoking",
      term == "COFFEE[T.Coffee]"       ~ "Coffee consumption",
      term == "HTT_CODE[T.IA]"         ~ "italic(HTT)~' IA'",
      term == "ATXN1_CODE[T.IA]"        ~ "italic(ATXN1)~' IA'",
      term == "ATXN2_CODE[T.IA]"        ~ "italic(ATXN2)~' IA'",
      TRUE ~ NA_character_
    ),
    sig05 = ifelse(p.value < 0.05, "Significant (p < 0.05)", "Not significant"),
    sig05 = factor(sig05, levels = c("Significant (p < 0.05)", "Not significant")),
    sig = -log10(pmax(p.value, 1e-300)),
    est_p = pmin(pmax(estimate,  x_min), x_max),
    lo_p  = pmin(pmax(conf.low,  x_min), x_max),
    hi_p  = pmin(pmax(conf.high, x_min), x_max),
    cut_left  = conf.low  < x_min,
    cut_right = conf.high > x_max
  ) %>%
  filter(!is.na(term_label))

order_terms <- c(
  "Female sex",
  "Non-smoking",
  "Coffee consumption",
  "italic(HTT)~' IA'",
  "italic(ATXN1)~' IA'",
  "italic(ATXN2)~' IA'"
)

df_fp <- df_fp %>%
  mutate(term_label = factor(term_label, levels = rev(order_terms)))

# 6) Forest plot
g_forest_D <- ggplot(df_fp, aes(x = est_p, y = term_label)) +
  coord_cartesian(xlim = c(x_min, x_max), clip = "off") +
  geom_vline(xintercept = 1, linetype = "dashed", linewidth = 0.6, color = "grey45") +
  
  geom_errorbarh(
    aes(xmin = lo_p, xmax = hi_p, color = sig05),
    height = 0.18, linewidth = 0.9
  ) +
  geom_point(
    aes(size = sig, fill = sig05),
    shape = 21, color = "black", stroke = 0.35
  ) +
  
  geom_segment(
    data = df_fp %>% filter(cut_left),
    aes(x = x_min * 1.35, xend = x_min * 1.08,
        y = term_label, yend = term_label, color = sig05),
    inherit.aes = FALSE,
    arrow = arrow(type = "closed", length = unit(0.16, "cm")),
    linewidth = 0.9
  ) +
  geom_segment(
    data = df_fp %>% filter(cut_right),
    aes(x = x_max / 1.35, xend = x_max / 1.08,
        y = term_label, yend = term_label, color = sig05),
    inherit.aes = FALSE,
    arrow = arrow(type = "closed", length = unit(0.16, "cm")),
    linewidth = 0.9
  ) +
  
  scale_x_log10(name = "Hazard ratio (log scale)") +
  scale_color_manual(
    name = "Statistical significance",
    values = c(
      "Significant (p < 0.05)" = col_sig,
      "Not significant"        = col_nsig
    )
  ) +
  scale_fill_manual(
    name = "Statistical significance",
    values = c(
      "Significant (p < 0.05)" = col_sig,
      "Not significant"        = col_nsig
    )
  ) +
  scale_size_continuous(
    name = expression(-log[10](p)),
    range = c(2.6, 6.8)
  ) +
  theme_classic(base_size = 12) +
  theme(
    legend.position = "top",
    legend.box = "vertical",
    axis.title.y = element_blank(),
    plot.margin = margin(8, 16, 8, 8)
  ) +
  scale_y_discrete(labels = function(x) {
    out <- x
    is_math <- grepl("^italic\\(", x)
    out[is_math] <- sapply(x[is_math], function(z) as.expression(parse(text = z)))
    out
  })

g_forest_D

# 7) Save
ggsave(
  filename = file.path(fig_dir, "Sup_Fig_2C.tiff"),
  plot = g_forest_D,
  device = "tiff",
  width = 250, height = 160, units = "mm",
  dpi = 600, compression = "lzw"
)

# Sup. Fig. 2D: K-M BD ATXN2 -----
surv_object <- Surv(time = BD$DURATION, event = rep(1, length(BD$DURATION)))
gen.km <- survfit(surv_object ~ ATXN2_CODE, data = BD, type = "kaplan-meier", error = "tsiatis", conf.type = "log-log", conf.int = 0.95)
bd_palette <- c("#F4A6A6", "#C73A3A")

plot_km <- ggsurvplot(
  fit = gen.km,
  data = BD,
  conf.int = TRUE,
  pval = TRUE,
  risk.table = TRUE,
  palette = bd_palette,
  xlab = "Disease duration (years)",
  ylab = "Event-free probability",
  legend.labs = c("Normal", "IA"),
  surv.median.line = "none",
  risk.table.height = 0.25
)

leg_title <- expression(italic("ATXN2") * " genotype")

plot_km$plot <- plot_km$plot +
  scale_color_manual(
    values = bd_palette,
    labels = c("Normal", "IA"),
    name = leg_title
  ) +
  scale_fill_manual(
    values = bd_palette,
    labels = c("Normal", "IA"),
    name = leg_title
  )

plot_km$table <- plot_km$table +
  labs(y = leg_title)

print(plot_km)

tiff(
  filename = file.path(fig_dir, "Sup_Fig_2D.tiff"),
  width = 250, height = 160, units = "mm",
  res = 600, compression = "lzw"
)
print(plot_km)
dev.off()

# Sup. Fig. 2E: K-M BD-CD ATXN2 -----
surv_object <- Surv(time = BD_CD$DURATION, event = rep(1, length(BD_CD$DURATION)))
gen.km <- survfit(surv_object ~ ATXN2_CODE, data = BD_CD, type = "kaplan-meier", error = "tsiatis", conf.type = "log-log", conf.int = 0.95)
bd_palette <- c("#D65C5C", "#7A1F1F")

plot_km_CD <- ggsurvplot(
  fit = gen.km,
  data = BD_CD,
  conf.int = TRUE,
  pval = TRUE,
  risk.table = TRUE,
  palette = bd_palette,
  xlab = "Disease duration (years)",
  ylab = "Event-free probability",
  legend.labs = c("Normal", "IA"),
  surv.median.line = "none",
  risk.table.height = 0.25
)

leg_title <- expression(italic("ATXN2") * " genotype")

plot_km_CD$plot <- plot_km_CD$plot +
  scale_color_manual(
    values = bd_palette,
    labels = c("Normal", "IA"),
    name = leg_title
  ) +
  scale_fill_manual(
    values = bd_palette,
    labels = c("Normal", "IA"),
    name = leg_title
  )

plot_km_CD$table <- plot_km_CD$table +
  labs(y = leg_title)

print(plot_km_CD)

tiff(
  filename = file.path(fig_dir, "Sup_Fig_2E.tiff"),
  width = 250, height = 160, units = "mm",
  res = 600, compression = "lzw"
)
print(plot_km_CD)
dev.off()

# Build composite figure ----

# KM + risk table as ONE patchwork object
km_as_one_panel <- function(km_obj, curve_h = 3.0, table_h = 1.2) {
  
  km_comp <- km_obj$plot / km_obj$table +
    plot_layout(heights = c(curve_h, table_h))
  
  wrap_elements(full = km_comp)
}

# D (left) and E (right), in that order
km_D <- km_as_one_panel(plot_km,    curve_h = 3.0, table_h = 1.2)
km_E <- km_as_one_panel(plot_km_CD, curve_h = 3.0, table_h = 1.2)

Sup_Fig_2 <-
  panel_A /
  (p_atxn1 | g_forest_D) /
  (km_D | km_E) +
  plot_layout(heights = c(1.15, 1.25, 1.75)) +
  plot_annotation(tag_levels = "A") &
  theme(
    plot.tag = element_text(face = "bold", size = 24),
    plot.tag.position = c(0, 1),
    plot.tag.padding = unit(4, "pt")
  )

Sup_Fig_2

ggsave(
  filename = file.path(fig_dir, "Supplementary Figure 2.tiff"),
  plot = Sup_Fig_2,
  device = "tiff",
  width = 500, height = 650, units = "mm",
  dpi = 600, compression = "lzw"
)

# Session info ----
sessionInfo()
```

## 07_Enrichr-KG

This script loads and visualizes an interaction network of miRNAs and their target genes, integrating enrichment results from multiple sources (e.g., GO, KEGG, DisGeNET). It provides both an overview of the full network and a filtered subnetwork focusing on *HTT*, *ATXN1*, and *ATXN2* and their immediate neighbors. Nodes are annotated and colored by source, and the network is visualized using both static and interactive layouts with `visNetwork`.

```{r}
# Load data ----

nodes <- read.delim(file.choose())   # Select your nodes file
edges <- read.delim(file.choose())   # Select your edges file

head(nodes)
head(edges)

# Initial visualization with visNetwork ----

# Prepare nodes for visNetwork
nodes_vis <- nodes[, c("id", "label", "kind", "color")]
nodes_vis$color <- ifelse(is.na(nodes_vis$color), "gray", nodes_vis$color)  # default to gray if missing

# Prepare edges for visNetwork
edges_vis <- edges
colnames(edges_vis)[colnames(edges_vis) == "source"] <- "from"
colnames(edges_vis)[colnames(edges_vis) == "target"] <- "to"
edges_vis$title <- edges_vis$relation  # shows relation on hover

# Plot interactive network
visNetwork(nodes_vis, edges_vis) %>%
  visPhysics(
    solver = "forceAtlas2Based",
    forceAtlas2Based = list(gravitationalConstant = -150),
    stabilization = list(enabled = TRUE, iterations = 1000),
    minVelocity = 0.1
  ) %>%
  visNodes(   
    color = list(border = "black", background = nodes_vis$color, highlight = "yellow"),
    font = list(size = 16, face = "bold", vadjust = 0),
    scaling = list(min = 10, max = 30)
  ) %>%
  visEdges(smooth = FALSE) %>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%
  visLayout(randomSeed = 123)

# Highlight target genes (HTT, ATXN1, ATXN2) ----

# Step 1: define target genes and color for each
target_genes <- c("HTT", "ATXN1", "ATXN2")
target_colors <- c("HTT" = "red", "ATXN1" = "blue", "ATXN2" = "green")

# Step 2: get IDs of the target nodes
target_node_ids <- nodes_vis$id[nodes_vis$label %in% target_genes]

# Step 3: initialize edge and node styles
edges_vis$color <- "gray"
edges_vis$width <- 1
edges_vis$dashes <- FALSE
nodes_vis$color_current <- nodes_vis$color

# Step 4: update color and width for each target gene
for (gene in target_genes) {
  gene_id <- nodes_vis$id[nodes_vis$label == gene]
  
  # Update node color
  nodes_vis$color_current[nodes_vis$id == gene_id] <- target_colors[gene]
  
  # Update edges connected to this gene
  idx_edges <- which(edges_vis$from == gene_id | edges_vis$to == gene_id)
  edges_vis$color[idx_edges] <- target_colors[gene]
  edges_vis$width[idx_edges] <- 3
}

# Step 5: visualize with updated styles
visNetwork(nodes_vis, edges_vis) %>%
  visPhysics(
    solver = "forceAtlas2Based",
    forceAtlas2Based = list(gravitationalConstant = -150),
    stabilization = TRUE
  ) %>%
  visNodes(
    color = list(border = "black", background = nodes_vis$color_current),
    font = list(size = 16, face = "bold", vadjust = 0, align = "center"),
    scaling = list(min = 10, max = 40)
  ) %>%
  visEdges(smooth = FALSE) %>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%
  visLayout(randomSeed = 123)


# Filter network to target genes and neighbors ----

# Rename columns to match igraph requirements
colnames(edges)[1:2] <- c("from", "to")
colnames(nodes)[1] <- "id"

# Create full graph
graph <- graph_from_data_frame(d = edges, vertices = nodes, directed = TRUE)

# Assign labels
V(graph)$label <- nodes$label[match(V(graph)$name, nodes$id)]

# Select target genes
target_nodes <- V(graph)[V(graph)$label %in% target_genes]

# Get 1st-degree neighbors (ego network)
neighbors <- ego(graph, order = 1, nodes = target_nodes, mode = "all")
included_nodes <- unique(unlist(neighbors))
subgraph <- induced_subgraph(graph, vids = included_nodes)

# Assign labels in the subgraph
V(subgraph)$label <- V(graph)$label[match(V(subgraph)$name, V(graph)$name)]


# Assign colors by node type ----

# Define color palette
node_types <- unique(V(subgraph)$kind)
palette_colors <- c(
  "DisGeNET"                            = "#D2DB7D",
  "GO Biological Process 2021"          = "#FFBAFB",
  "Gene"                                = "#C5E1A5",
  "Human Phenotype Ontology"            = "#B6D7FF",
  "KEGG 2021 Human"                     = "#E9E7F0",
  "MGI Mammalian Phenotype Level 4 2021"= "#FF9600"
)

# Prepare subgraph nodes
sub_nodes <- data.frame(
  id = V(subgraph)$name,
  label = V(subgraph)$label,
  kind = V(subgraph)$kind,
  color = palette_colors[V(subgraph)$kind],
  stringsAsFactors = FALSE
)

# Prepare subgraph edges
sub_edges <- igraph::as_data_frame(subgraph, what = "edges")

# Add legend for node types ----

legend_nodes <- data.frame(
  label = names(palette_colors),
  shape = "dot",
  color = unname(palette_colors),
  size = 15,
  stringsAsFactors = FALSE
)

# Simplify legend labels
legend_nodes$label <- c("DisGeNET", "GO BP", "Gene", "HP", "KEGG", "MP")


# Final visualization of subgraph ----

visNetwork(sub_nodes, sub_edges) %>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%
  visNodes(
    color = list(border = "black", background = sub_nodes$color, highlight = "yellow"),
    borderWidth = 1,
    font = list(face = "bold")
  ) %>%
  visLayout(randomSeed = 123) %>%
  visPhysics(enabled = FALSE) %>%
  visLegend(
    useGroups = FALSE,
    addNodes = legend_nodes,
    position = "left"
  )

# Session info ----
sessionInfo()
```
